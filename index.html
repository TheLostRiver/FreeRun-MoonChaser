<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<title>Free Run: Moon Chaser (V23)</title>
	<style>
		@import url('https://fonts.googleapis.com/css2?family=Titan+One&display=swap');
		@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@900&display=swap');

		body {
			margin: 0;
			overflow: hidden;
			background-color: #050520;
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			user-select: none;
			-webkit-user-select: none;
		}

		#gameCanvas {
			display: block;
			width: 100vw;
			height: 100vh;
		}

		#ui-layer {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
		}

		.btn-3d {
			pointer-events: auto;
			border: none;
			outline: none;
			cursor: pointer;
			font-family: 'Titan One', 'Noto Sans SC', sans-serif;
			text-transform: uppercase;
			transition: transform 0.1s;
		}

		.btn-3d:active {
			transform: translateY(4px);
			box-shadow: 0 0px 0 rgba(0, 0, 0, 0.2) !important;
		}

		/* é¡¶éƒ¨æŒ‰é’®ç»„ */
		.top-btn {
			position: absolute;
			top: 20px;
			background: rgba(0, 0, 0, 0.6);
			color: white;
			border: 2px solid rgba(255, 255, 255, 0.5);
			padding: 8px 16px;
			border-radius: 20px;
			font-weight: bold;
			font-size: 14px;
			z-index: 500;
			cursor: pointer;
			pointer-events: auto;
		}

		#lang-btn {
			left: 20px;
		}

		#sound-btn {
			left: 120px;
			width: 40px;
			text-align: center;
			padding: 8px 0;
		}

		#pause-btn {
			position: absolute;
			top: 20px;
			left: 180px;
			background: rgba(230, 126, 34, 0.8);
			color: white;
			border: 2px solid rgba(255, 255, 255, 0.5);
			width: 40px;
			height: 40px;
			border-radius: 50%;
			font-weight: bold;
			font-size: 18px;
			line-height: 36px;
			text-align: center;
			z-index: 500;
			cursor: pointer;
			pointer-events: auto;
			box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
			font-family: 'Segoe UI', sans-serif !important;
			/* å¼ºåˆ¶ä½¿ç”¨ç³»ç»Ÿå­—ä½“ï¼Œé˜²æ­¢è‰ºæœ¯å­—ä½“ææ€ª */
			font-size: 24px;
			/* ç¨å¾®å¤§ä¸€ç‚¹ */
			padding-top: 2px;
			/* å¾®è°ƒå‚ç›´å±…ä¸­ */
			line-height: 38px;
		}

		#pause-btn:hover {
			background: #d35400;
		}

		/* HUD */
		#hud-panel {
			position: absolute;
			top: 20px;
			right: 20px;
			display: flex;
			flex-direction: column;
			align-items: flex-end;
			transition: opacity 0.3s;
		}

		#score-display {
			font-family: 'Titan One', 'Noto Sans SC', cursive;
			font-size: 36px;
			color: white;
			text-shadow: 3px 3px 0 #000;
			margin-bottom: 5px;
		}

		.coin-container {
			display: flex;
			align-items: center;
			background: rgba(0, 0, 0, 0.5);
			padding: 5px 12px;
			border-radius: 15px;
			border: 1px solid rgba(255, 255, 255, 0.2);
			margin-bottom: 5px;
		}

		.css-coin {
			width: 20px;
			height: 20px;
			background: linear-gradient(135deg, #ffd700, #ffaa00);
			border: 2px solid #fff;
			border-radius: 50%;
			margin-right: 8px;
			box-shadow: 0 0 5px rgba(255, 215, 0, 0.6);
		}

		#coin-display {
			font-size: 20px;
			font-weight: bold;
			color: #FFD700;
			text-shadow: 1px 1px 0 #000;
		}

		#coin-multiplier {
			font-size: 16px;
			font-weight: 900;
			font-family: monospace;
			color: #00FFFF;
			margin-left: 8px;
			font-style: italic;
			text-shadow: 0 0 5px rgba(0, 255, 255, 0.8);
		}

		#speed-indicator {
			font-family: 'Titan One', monospace;
			color: #00FFFF;
			font-size: 18px;
			text-shadow: 1px 1px 0 #000;
			margin-bottom: 10px;
			font-style: italic;
		}

		#status-bars {
			display: flex;
			flex-direction: column;
			gap: 5px;
			margin-top: 5px;
			align-items: flex-end;
		}

		.status-bar {
			display: flex;
			align-items: center;
			padding: 5px 15px;
			border-radius: 20px;
			border: 2px solid #fff;
			transform: scale(0);
			transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
			transform-origin: right center;
			margin-bottom: 5px;
		}

		.status-bar.active {
			transform: scale(1);
		}

		.status-icon {
			font-size: 20px;
			margin-right: 8px;
		}

		.status-timer {
			color: white;
			font-weight: 900;
			font-family: monospace;
			font-size: 18px;
		}

		/* æ–°å¢ï¼šæŠ¤ç›¾çš„èƒŒæ™¯æ¸å˜ (é’è“è‰²ï¼ŒåŒºåˆ«äºå–·æ°”èƒŒåŒ…çš„æ·±è“) */
		#shield-status {
			background: linear-gradient(90deg, #1abc9c, #16a085);
			/* é»˜è®¤éšè—ï¼Œé€šè¿‡æ·»åŠ  .active ç±»æ˜¾ç¤º */
			display: flex;
			opacity: 0;
			transition: opacity 0.3s;
		}

		/* å½“æŠ¤ç›¾å¤„äºæ¿€æ´»çŠ¶æ€ (æœ‰ç›¾ æˆ– æ— æ•Œä¸­) æ—¶æ˜¾ç¤º */
		#shield-status.active {
			opacity: 1;
			transform: scale(1);
		}

		/* æ— æ•Œæ—¶é—´çš„é—ªçƒåŠ¨ç”» */
		@keyframes shieldBlink {
			0% {
				opacity: 1;
			}

			50% {
				opacity: 0.5;
			}

			100% {
				opacity: 1;
			}
		}

		.shield-flicker {
			animation: shieldBlink 0.2s infinite;
		}

		#jetpack-status {
			background: linear-gradient(90deg, #3498db, #2980b9);
		}

		#magnet-status {
			background: linear-gradient(90deg, #e74c3c, #c0392b);
		}

		.menu-screen {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(25, 25, 112, 0.4);
			backdrop-filter: blur(4px);
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			pointer-events: auto;
			transition: opacity 0.3s;
			z-index: 150;
			cursor: default;
		}

		.hidden {
			display: none !important;
		}

		.game-title {
			font-family: 'Titan One', 'Noto Sans SC', sans-serif;
			font-weight: 900;
			font-size: 60px;
			line-height: 1.2;
			text-align: center;
			color: #FFD700;
			text-shadow: 2px 2px 0 #000, 0 5px 0 #d35400, 0 8px 10px rgba(0, 0, 0, 0.5);
			transform: skewY(-3deg);
			margin-bottom: 40px;
			animation: floatTitle 3s ease-in-out infinite;
		}

		@keyframes floatTitle {

			0%,
			100% {
				transform: skewY(-3deg) translateY(0);
			}

			50% {
				transform: skewY(-3deg) translateY(-10px);
			}
		}

		.menu-content {
			display: flex;
			flex-direction: column;
			align-items: center;
			z-index: 160;
		}

		.play-btn-style {
			background-color: #2ecc71;
			color: white;
			font-size: 28px;
			padding: 15px 60px;
			border-radius: 50px;
			box-shadow: 0 6px 0 #219150;
			margin-bottom: 20px;
		}

		.store-btn-style {
			background-color: #9b59b6;
			color: white;
			font-size: 18px;
			padding: 10px 40px;
			border-radius: 30px;
			box-shadow: 0 5px 0 #8e44ad;
			margin-bottom: 10px;
		}

		/* è§’è‰²æŒ‰é’®æ ·å¼ */
		.char-btn-style {
			background-color: #e67e22;
			color: white;
			font-size: 18px;
			padding: 10px 40px;
			border-radius: 30px;
			box-shadow: 0 5px 0 #d35400;
			margin-bottom: 10px;
		}

		.rank-btn-style {
			background-color: #f39c12;
			color: white;
			font-size: 18px;
			padding: 10px 40px;
			border-radius: 30px;
			box-shadow: 0 5px 0 #d35400;
			margin-bottom: 20px;
		}

		.retry-btn-style {
			background-color: #e74c3c;
			color: white;
			font-size: 24px;
			padding: 12px 40px;
			border-radius: 50px;
			box-shadow: 0 6px 0 #c0392b;
		}

		.home-btn-style {
			margin-top: 15px;
			background: #3498db;
			padding: 10px 20px;
			font-size: 16px;
			border-radius: 20px;
			color: white;
			box-shadow: 0 4px 0 #2980b9;
		}

		#pause-screen {
			z-index: 400;
			background: rgba(0, 0, 0, 0.6);
		}

		.pause-container {
			background: rgba(20, 20, 50, 0.9);
			padding: 40px 60px;
			border-radius: 20px;
			border: 3px solid #00FFFF;
			box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
			text-align: center;
			display: flex;
			flex-direction: column;
			gap: 20px;
		}

		.pause-title {
			font-family: 'Titan One', 'Noto Sans SC';
			font-size: 48px;
			color: white;
			text-shadow: 0 0 10px #00FFFF;
			margin-bottom: 10px;
		}

		.resume-btn-style {
			background-color: #2ecc71;
			color: white;
			font-size: 24px;
			padding: 10px 40px;
			border-radius: 30px;
			box-shadow: 0 5px 0 #27ae60;
		}

		/* Generic Modal (Store & Characters) */
		#store-screen,
		#char-screen {
			z-index: 250;
		}

		.store-container {
			background: rgba(10, 10, 40, 0.95);
			padding: 25px;
			border-radius: 20px;
			border: 2px solid #00FFFF;
			box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
			width: 90%;
			max-width: 600px;
			max-height: 85vh;
			overflow-y: auto;
			display: flex;
			flex-direction: column;
			align-items: center;
		}

		.store-header {
			width: 100%;
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 20px;
			border-bottom: 1px solid rgba(255, 255, 255, 0.2);
			padding-bottom: 10px;
			flex-shrink: 0;
		}

		.store-balance {
			display: flex;
			align-items: center;
			font-size: 24px;
			color: #FFD700;
			font-weight: bold;
		}

		.store-grid {
			display: flex;
			gap: 20px;
			justify-content: center;
			flex-wrap: wrap;
			width: 100%;
			padding-bottom: 20px;
		}

		.store-item {
			background: rgba(255, 255, 255, 0.05);
			width: 220px;
			border-radius: 15px;
			padding: 15px;
			display: flex;
			flex-direction: column;
			align-items: center;
			border: 1px solid rgba(255, 255, 255, 0.1);
			transition: transform 0.2s;
		}

		.store-item:hover {
			transform: translateY(-5px);
			border-color: #00FFFF;
		}

		.item-icon {
			font-size: 40px;
			margin-bottom: 10px;
		}

		.item-name {
			color: white;
			font-weight: bold;
			font-size: 18px;
			margin-bottom: 5px;
		}

		.item-desc {
			color: #aaa;
			font-size: 12px;
			text-align: center;
			margin-bottom: 15px;
			height: 30px;
		}

		.buy-btn {
			background: #27ae60;
			color: white;
			border: none;
			padding: 8px 20px;
			border-radius: 20px;
			font-weight: bold;
			cursor: pointer;
			display: flex;
			align-items: center;
			gap: 5px;
			margin-bottom: 10px;
			box-shadow: 0 4px 0 #219150;
		}

		.buy-btn:active {
			transform: translateY(2px);
			box-shadow: 0 2px 0 #219150;
		}

		.buy-btn:disabled {
			background: #555;
			box-shadow: none;
			cursor: not-allowed;
			opacity: 0.6;
		}

		/* è§’è‰²æŒ‰é’®ç‰¹å®šæ ·å¼ */
		.buy-btn.equipped {
			background: #555;
			cursor: default;
			box-shadow: none;
		}

		.buy-btn.select {
			background: #e67e22;
			box-shadow: 0 4px 0 #d35400;
		}

		.item-owned {
			color: #00FFFF;
			font-size: 14px;
			margin-bottom: 8px;
			font-weight: bold;
		}

		.toggle-container {
			display: flex;
			align-items: center;
			gap: 10px;
			color: white;
			font-size: 14px;
		}

		.switch {
			position: relative;
			display: inline-block;
			width: 40px;
			height: 20px;
		}

		.switch input {
			opacity: 0;
			width: 0;
			height: 0;
		}

		.slider {
			position: absolute;
			cursor: pointer;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background-color: #ccc;
			transition: .4s;
			border-radius: 20px;
		}

		.slider:before {
			position: absolute;
			content: "";
			height: 16px;
			width: 16px;
			left: 2px;
			bottom: 2px;
			background-color: white;
			transition: .4s;
			border-radius: 50%;
		}

		input:checked+.slider {
			background-color: #00FFFF;
		}

		input:checked+.slider:before {
			transform: translateX(20px);
		}

		#main-menu-coins {
			position: absolute;
			top: 20px;
			right: 20px;
			font-size: 24px;
			color: #FFD700;
			font-weight: bold;
			text-shadow: 2px 2px 0 #000;
			display: flex;
			align-items: center;
			gap: 5px;
		}

		#controls-hint {
			margin-top: 30px;
			background: rgba(10, 10, 30, 0.85);
			padding: 20px 30px;
			border-radius: 20px;
			border: 2px solid rgba(0, 255, 255, 0.3);
			display: flex;
			flex-direction: column;
			gap: 15px;
			align-items: center;
			pointer-events: none;
			box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
			backdrop-filter: blur(5px);
		}

		.control-row {
			display: flex;
			align-items: center;
			gap: 15px;
			color: #fff;
			font-weight: bold;
			font-size: 14px;
			font-family: 'Titan One', sans-serif;
			text-shadow: 1px 1px 2px black;
		}

		.key-cap {
			display: inline-block;
			min-width: 32px;
			height: 32px;
			background: #222;
			color: #eee;
			font-family: 'Segoe UI', sans-serif;
			font-weight: 900;
			line-height: 30px;
			text-align: center;
			padding: 0 8px;
			border-radius: 6px;
			border-bottom: 4px solid #000;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
			transform: translateY(0);
		}

		.key-move {
			border-bottom-color: #008B8B;
			color: #00FFFF;
		}

		.key-jump {
			border-bottom-color: #B8860B;
			color: #FFD700;
		}

		.key-roll {
			border-bottom-color: #8B008B;
			color: #FF00FF;
		}

		.control-label {
			color: #ddd;
			font-size: 12px;
			letter-spacing: 1px;
			text-transform: uppercase;
		}

		.swipe-hint {
			display: flex;
			align-items: center;
			gap: 8px;
			color: #aaa;
			font-size: 12px;
			font-style: italic;
			margin-top: 5px;
		}

		.swipe-icon {
			font-size: 16px;
		}

		#leaderboard-screen {
			z-index: 200;
		}

		.leaderboard-container {
			background: rgba(0, 0, 0, 0.9);
			padding: 20px;
			border-radius: 25px;
			border: 3px solid #FFD700;
			width: 90%;
			max-width: 450px;
			max-height: 70vh;
			overflow-y: auto;
		}

		.lb-table {
			width: 100%;
			border-collapse: collapse;
			color: white;
			font-family: sans-serif;
		}

		.lb-table th {
			color: #FFD700;
			padding: 10px;
			border-bottom: 2px solid #555;
			cursor: pointer;
		}

		.lb-table td {
			padding: 8px;
			text-align: center;
			border-bottom: 1px solid #333;
		}

		.lb-close-btn {
			margin-top: 25px;
			background: #e74c3c;
			font-size: 20px;
			padding: 10px 40px;
			border-radius: 30px;
			box-shadow: 0 5px 0 #c0392b;
			flex-shrink: 0;
		}

		.sort-icon {
			font-size: 14px;
			margin-left: 8px;
			opacity: 0.8;
			color: #FFD700;
		}

		#name-input {
			font-size: 20px;
			padding: 10px;
			border-radius: 10px;
			text-align: center;
			margin-bottom: 15px;
		}

		#loading {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			color: white;
			font-weight: bold;
		}

		#game-over {
			z-index: 300;
		}

		/* =========================================
       ç§»åŠ¨ç«¯é€‚é…ä¸“ç”¨ä»£ç  (Mobile Responsive)
       æŠŠè¿™æ®µåŠ åˆ° <style> çš„æœ€åé¢
       ========================================= */
		@media only screen and (max-width: 768px) {

			/* 1. æ ‡é¢˜é€‚é…ï¼šç¼©å°å­—å·ï¼Œå¢åŠ é¡¶éƒ¨ç•™ç™½ï¼Œé˜²æ­¢è¢«å·¦ä¸Šè§’æŒ‰é’®é®æŒ¡ */
			.game-title {
				font-size: 32px !important;
				/* ä» 60px ç¼©å°åˆ° 32px */
				margin-top: 70px !important;
				/* è®©å‡ºé¡¶éƒ¨ç©ºé—´ç»™åŠŸèƒ½æŒ‰é’® */
				margin-bottom: 20px !important;
				line-height: 1.2;
				width: 90%;
				/* é˜²æ­¢æ ‡é¢˜å¤ªå®½æ’‘å‡ºå±å¹• */
				max-width: 100%;
			}

			/* 2. é¡¶éƒ¨åŠŸèƒ½æŒ‰é’®ï¼šç¨å¾®ç¼©å°ä¸€ç‚¹ï¼Œé è¾¹ç´§å‡‘ä¸€ç‚¹ */
			.top-btn {
				padding: 6px 12px !important;
				font-size: 12px !important;
				top: 15px !important;
				border-width: 1px !important;
			}

			#lang-btn {
				left: 15px !important;
			}

			#sound-btn {
				left: 100px !important;
				width: 36px !important;
			}

			/* 3. ä¸»èœå•é‡‘å¸ï¼šè°ƒæ•´ä½ç½®é˜²æ­¢é‡å  */
			#main-menu-coins {
				top: 15px !important;
				right: 15px !important;
				font-size: 20px !important;
			}

			/* 4. èœå•æŒ‰é’®ç»„ï¼šæ•´ä½“ç¼©å°ï¼Œå‡å°‘é—´è· */
			.play-btn-style {
				font-size: 20px !important;
				padding: 12px 50px !important;
				margin-bottom: 12px !important;
				width: 70%;
				/* é™åˆ¶å®½åº¦ */
			}

			.store-btn-style,
			.char-btn-style,
			.rank-btn-style {
				font-size: 14px !important;
				padding: 8px 30px !important;
				margin-bottom: 8px !important;
				width: 60%;
			}

			/* 5. æ ¸å¿ƒä¼˜åŒ–ï¼šæ“ä½œè¯´æ˜æ¡† */
			#controls-hint {
				padding: 10px 20px !important;
				margin-top: 15px !important;
				width: 80%;
				background: rgba(10, 10, 30, 0.6) !important;
				/* ç¨å¾®é€æ˜ä¸€ç‚¹ */
			}

			/* å…³é”®ï¼šåœ¨æ‰‹æœºä¸Šç›´æ¥éšè—é”®ç›˜æŒ‰é”®æç¤ºï¼æ‰‹æœºç©å®¶ä¸éœ€è¦çœ‹è¿™ä¸ªï¼ */
			#controls-hint .control-row {
				display: none !important;
			}

			/* æ”¾å¤§å¹¶é«˜äº®â€œæ»‘åŠ¨å±å¹•â€æç¤ºï¼Œè¿™æ‰æ˜¯æ‰‹æœºç©å®¶éœ€è¦çš„ */
			.swipe-hint {
				font-size: 16px !important;
				color: #00FFFF !important;
				margin-top: 0 !important;
				font-weight: bold;
				display: flex;
				justify-content: center;
			}

			/* 6. æ¸¸æˆå†… HUD (åˆ†æ•°æ ) æ•´ä½“ç¼©å° */
			#hud-panel {
				top: 10px !important;
				right: 10px !important;
				transform: scale(0.75);
				/* æ•´ä½“ç¼©æ”¾ 75% */
				transform-origin: top right;
			}
		}
	</style>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

	<div id="loading">Loading Engine...</div>
	<div id="game-container"></div>

	<div id="ui-layer">
		<button id="lang-btn" class="btn-3d top-btn">CN / EN</button>
		<button id="sound-btn" class="btn-3d top-btn" onclick="AudioSys.toggle()">ğŸ”Š</button>
		<div id="pause-btn" class="hidden" onclick="togglePause(event)">â¸</div>

		<div id="hud-panel" class="hidden">
			<div id="score-display">000000</div>
			<div id="speed-indicator">SPEED: 1.0x</div>
			<div class="coin-container">
				<div class="css-coin"></div>
				<div id="coin-display">0</div>
				<span id="coin-multiplier">x1</span>
			</div>

			<div id="status-bars">
				<div id="jetpack-status" class="status-bar">
					<div class="status-icon">ğŸš€</div>
					<div id="jetpack-timer" class="status-timer">08.0s</div>
				</div>
				<div id="magnet-status" class="status-bar">
					<div class="status-icon">ğŸ§²</div>
					<div id="magnet-timer" class="status-timer">10.0s</div>
				</div>

				<div id="shield-status" class="status-bar">
					<div class="status-icon">ğŸ›¡ï¸</div>
					<div id="shield-text" class="status-timer">READY</div>
				</div>
			</div>
		</div>

		<div id="main-menu" class="menu-screen">
			<div id="main-menu-coins">
				<div class="css-coin"></div>
				<span id="menu-coin-count">0</span>
			</div>
			<div class="game-title">FREE RUN<br>MOON CHASER</div>

			<div class="menu-content">
				<button id="play-btn" class="btn-3d play-btn-style" onclick="startGame(event)">TAP TO
					PLAY</button>
				<button id="store-btn" class="btn-3d store-btn-style" onclick="Store.show(event)">SUPPLY
					STORE</button>
				<button id="char-btn" class="btn-3d char-btn-style"
					onclick="CharSys.show(event)">CHARACTERS</button>
				<button id="rank-btn" class="btn-3d rank-btn-style"
					onclick="Leaderboard.show(event)">LEADERBOARD</button>
			</div>

			<div id="controls-hint">
				<div class="control-row">
					<div><span class="key-cap key-move">â†</span> <span
							class="key-cap key-move">â†’</span></div>
					<span class="control-label">MOVE</span>
				</div>
				<div class="control-row">
					<div><span class="key-cap key-jump">â†‘</span></div>
					<span class="control-label">JUMP</span>
					<div style="width:15px"></div>
					<div><span class="key-cap key-roll">â†“</span></div>
					<span class="control-label">ROLL</span>
				</div>
				<div class="swipe-hint"><span class="swipe-icon">ğŸ‘†</span> (Swipe on Screen)</div>
			</div>
		</div>

		<div id="pause-screen" class="menu-screen hidden">
			<div class="pause-container">
				<div id="pause-title" class="pause-title">PAUSED</div>
				<button id="resume-btn" class="btn-3d resume-btn-style"
					onclick="togglePause(event)">RESUME</button>
				<button id="pause-home-btn" class="btn-3d lb-close-btn" onclick="goHome(event)">MAIN
					MENU</button>
			</div>
		</div>

		<div id="store-screen" class="menu-screen hidden">
			<div class="store-container">
				<div class="store-header">
					<div class="game-title"
						style="font-size:30px; margin:0; transform:none; animation:none;">SUPPLY
						STORE</div>
					<div class="store-balance">
						<div class="css-coin" style="width:25px; height:25px;"></div>
						<span id="store-coin-count">0</span>
					</div>
				</div>
				<div class="store-grid">
					<div class="store-item">
						<div class="item-icon">ğŸ§²</div>
						<div id="item-name-mag" class="item-name">Magnet Start</div>
						<div id="item-desc-mag" class="item-desc">Start run with Magnet active
						</div>
						<div id="item-own-mag" class="item-owned">Owned: 0</div>
						<button id="buy-mag-btn" class="buy-btn" onclick="Store.buy('magnet')">
							<div class="css-coin" style="width:15px; height:15px;"></div>
							100
						</button>
						<div class="toggle-container">
							<label class="switch">
								<input type="checkbox" id="check-mag"
									onchange="Store.toggle('magnet')">
								<span class="slider"></span>
							</label>
							<span id="auto-use-mag">Auto-Use</span>
						</div>
					</div>
					<div class="store-item">
						<div class="item-icon">ğŸš€</div>
						<div id="item-name-jet" class="item-name">Jetpack Start</div>
						<div id="item-desc-jet" class="item-desc">Start run with Jetpack active
						</div>
						<div id="item-own-jet" class="item-owned">Owned: 0</div>
						<button id="buy-jet-btn" class="buy-btn" onclick="Store.buy('jetpack')">
							<div class="css-coin" style="width:15px; height:15px;"></div>
							200
						</button>
						<div class="toggle-container">
							<label class="switch">
								<input type="checkbox" id="check-jet"
									onchange="Store.toggle('jetpack')">
								<span class="slider"></span>
							</label>
							<span id="auto-use-jet">Auto-Use</span>
						</div>
					</div>
				</div>
				<button id="store-close-btn" class="btn-3d lb-close-btn"
					style="background:#3498db; box-shadow:0 5px 0 #2980b9;"
					onclick="closeStore(event)">BACK</button>
			</div>
		</div>

		<div id="char-screen" class="menu-screen hidden">
			<div class="store-container">
				<div class="store-header">
					<div id="char-title" class="game-title"
						style="font-size:30px; margin:0; transform:none; animation:none;">
						CHARACTERS</div>
					<div class="store-balance">
						<div class="css-coin" style="width:25px; height:25px;"></div>
						<span id="char-coin-count">0</span>
					</div>
				</div>
				<div id="char-grid" class="store-grid">
				</div>
				<button id="char-close-btn" class="btn-3d lb-close-btn"
					style="background:#3498db; box-shadow:0 5px 0 #2980b9;"
					onclick="CharSys.close(event)">BACK</button>
			</div>
		</div>

		<div id="game-over" class="menu-screen hidden">
			<div class="game-title" style="font-size: 48px; color: #ff6b6b;">CRASHED!</div>
			<div id="final-score-box"
				style="background:rgba(0,0,0,0.6); padding:15px; border-radius:15px; text-align:center; margin-bottom:15px;">
				<div style="color:white; font-size: 16px;">SCORE</div>
				<div id="final-score-val" style="color:#FFD700; font-size:36px; font-weight:900;">0
				</div>
			</div>
			<input type="text" id="name-input" placeholder="Enter Name" maxlength="8">
			<button id="restart-btn" class="btn-3d retry-btn-style">SAVE & RETRY</button>
			<button id="home-btn" class="btn-3d home-btn-style" onclick="goHome(event)">MAIN MENU</button>
		</div>

		<div id="leaderboard-screen" class="menu-screen hidden">
			<div class="leaderboard-container">
				<div id="lb-title-text" class="game-title"
					style="font-size: 32px; margin-bottom: 20px;">TOP RUNNERS
				</div>
				<table class="lb-table">
					<thead>
						<tr>
							<th id="th-rank">RANK</th>
							<th id="th-name" onclick="Leaderboard.sort('name')">NAME <span
									id="sort-name" class="sort-icon"></span></th>
							<th id="th-score" onclick="Leaderboard.sort('score')">SCORE
								<span id="sort-score" class="sort-icon">â–¼</span>
							</th>
							<th id="th-time" onclick="Leaderboard.sort('time')">TIME <span
									id="sort-time" class="sort-icon"></span></th>
						</tr>
					</thead>
					<tbody id="lb-body"></tbody>
				</table>
				<button id="lb-close-btn" class="btn-3d lb-close-btn"
					onclick="document.getElementById('leaderboard-screen').classList.add('hidden')">CLOSE</button>
			</div>
		</div>
	</div>

	<script>
		/**
		 * FREE RUN: MOON CHASER (V23 - V20 Base + Character System)
		 */

		const CONFIG = {
			LANES: [-3.5, 0, 3.5],
			TRACK_LENGTH: 200,
			PLAYER_SPEED_BASE: 15,
			PLAYER_SPEED_MAX: 50,
			SPEED_ACCELERATION: 0.8,
			JUMP_FORCE: 0.4,
			GRAVITY: 0.015,
			MAGNET_DURATION: 10,
			JETPACK_DURATION: 8,
			JETPACK_HEIGHT: 7,
			MAGNET_RANGE: 15,
			COST_MAGNET: 100,
			COST_JETPACK: 200,
			INITIAL_COINS: 50000,
			CYCLE_DURATION: 120,
			START_TIME_OFFSET: 0.5, // 0.0=é»‘å¤œ, 0.25=æ—¥å‡º, 0.5=æ­£åˆ, 0.75=æ—¥è½
			MOVING_TRAIN_SPAWN_OFFSET: 180,
			TRAIN_COOLDOWN: 3000,
			INVINCIBLE_DURATION: 3.0, // æ— æ•Œæ—¶é—´ 3ç§’
			COLORS: {
				skyNight: 0x050520, skySunrise: 0xFF8C00, skyDay: 0x87CEEB, skySunset: 0x800080,
				coin: 0xFFD700, ground: 0x333344
			},

			// æ–°å¢ï¼šç‰¹æ®Šé‡‘å¸é…ç½®
			SPECIAL_COINS: {
				gem: {
					value: 50,
					color: 0x00FFFF, // é’è‰²
					chance: 0.08,    // å‡ºç°æ¦‚ç‡ 8% (æ›¿ä»£åŸæœ¬çš„ä¸€ç»„é‡‘å¸)
					rotateSpeed: 2.0
				},
				star: {
					value: 100,
					color: 0xE74C3C, // çº¢è‰²/ç´«è‰²æ ¸å¿ƒ
					ringColor: 0xFFD700, // é‡‘è‰²ç¯
					chance: 0.03,    // å‡ºç°æ¦‚ç‡ 3%
					rotateSpeed: 1.5
				}
			},

			// æ–°å¢ï¼šäº‘å±‚é…ç½®
			CLOUDS: {
				count: 15,          // äº‘æœµæ•°é‡
				minHeight: 25,      // æœ€ä½é«˜åº¦
				maxHeight: 60,      // æœ€é«˜é«˜åº¦
				rangeX: 100,        // å·¦å³åˆ†å¸ƒèŒƒå›´
				depth: 300,         // å‰ååˆ†å¸ƒæ·±åº¦
				speed: 5            // äº‘æœµé£˜åŠ¨é€Ÿåº¦
			}
		};

		let currentGroundY = 0; // å½“å‰çš„åœ°é¢é«˜åº¦ (0=åœ°é¢, 4=è½¦é¡¶)
		let onTrain = false;    // ç©å®¶å½“å‰æ˜¯å¦åœ¨ç«è½¦ä¸Š

		// --- V23: Character Data ---
		const CHARACTERS = {
			'default': { name: "Runner", color: 0xE0E0E0, glow: 0x00FFFF, cost: 0 },
			'crimson': { name: "Crimson", color: 0xE74C3C, glow: 0xFFD700, cost: 500 },
			'stealth': { name: "Stealth", color: 0x2C3E50, glow: 0xFF00FF, cost: 1000 },
			'golden': { name: "Midas", color: 0xFFD700, glow: 0xFFFFFF, cost: 2000 }
		};

		const AudioSys = {
			ctx: null,
			muted: false,
			bgmOscillators: [],
			isPlayingBGM: false,

			init: function () {
				if (!this.ctx) {
					const AudioContext = window.AudioContext || window.webkitAudioContext;
					this.ctx = new AudioContext();
				}
				if (this.ctx.state === 'suspended') this.ctx.resume();
			},

			toggle: function () {
				this.muted = !this.muted;
				document.getElementById('sound-btn').innerText = this.muted ? "ğŸ”‡" : "ğŸ”Š";
				if (this.muted) this.stopBGM();
				else if (gameActive && !isPaused) this.startBGM();
			},

			playTone: function (freq, type, duration, vol) {
				if (this.muted || !this.ctx) return;
				const osc = this.ctx.createOscillator();
				const gain = this.ctx.createGain();
				osc.type = type;
				osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
				gain.gain.setValueAtTime(vol, this.ctx.currentTime);
				gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
				osc.connect(gain);
				gain.connect(this.ctx.destination);
				osc.start();
				osc.stop(this.ctx.currentTime + duration);
			},

			playCoin: function () {
				if (this.muted) return;
				this.playTone(1200, 'sine', 0.1, 0.1);
				setTimeout(() => this.playTone(1800, 'sine', 0.2, 0.1), 50);
			},

			playPowerup: function () {
				if (this.muted || !this.ctx) return;
				const osc = this.ctx.createOscillator();
				const gain = this.ctx.createGain();
				osc.type = 'sawtooth';
				osc.frequency.setValueAtTime(200, this.ctx.currentTime);
				osc.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + 0.5);
				gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
				gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
				osc.connect(gain); gain.connect(this.ctx.destination);
				osc.start(); osc.stop(this.ctx.currentTime + 0.5);
			},

			playCrash: function () {
				if (this.muted || !this.ctx) return;
				const bufferSize = this.ctx.sampleRate * 0.5; // 0.5 sec noise
				const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
				const data = buffer.getChannelData(0);
				for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
				const noise = this.ctx.createBufferSource();
				noise.buffer = buffer;
				const gain = this.ctx.createGain();
				gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
				gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
				noise.connect(gain); gain.connect(this.ctx.destination);
				noise.start();
			},

			// å¤„ç† æ’å‡»å£°å’Œ ç ´ç¢å£°
			playSmash: function (isBig) {
				if (this.muted || !this.ctx) return;
				const osc = this.ctx.createOscillator();
				const gain = this.ctx.createGain();

				// å¤§æ’å‡»ï¼ˆæ’ç«è½¦ï¼‰ç”¨ä½é¢‘é”¯é½¿æ³¢ï¼Œå°æ’å‡»ï¼ˆæ’æ æ†ï¼‰ç”¨æ–¹æ³¢
				osc.type = isBig ? 'sawtooth' : 'square';

				// é¢‘ç‡å¿«é€Ÿä¸‹é™æ¨¡æ‹Ÿæ’å‡»
				osc.frequency.setValueAtTime(isBig ? 100 : 300, this.ctx.currentTime);
				osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.15);

				// éŸ³é‡æ§åˆ¶ï¼šä¸èƒ½å¤ªåµ
				const vol = isBig ? 0.3 : 0.15;
				gain.gain.setValueAtTime(vol, this.ctx.currentTime);
				gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);

				osc.connect(gain);
				gain.connect(this.ctx.destination);

				osc.start();
				osc.stop(this.ctx.currentTime + 0.2);
			},

			startBGM: function () {
				if (this.muted || !this.ctx || this.isPlayingBGM) return;
				this.isPlayingBGM = true;
				this.bgmTimer = setInterval(() => {
					if (!this.isPlayingBGM) return;
					const t = this.ctx.currentTime;
					const bassFreq = [55, 55, 55, 55, 65, 65, 49, 49][Math.floor(Date.now() / 250) % 8];
					const osc = this.ctx.createOscillator();
					const gain = this.ctx.createGain();
					osc.type = 'sawtooth';
					osc.frequency.setValueAtTime(bassFreq, t);
					const filter = this.ctx.createBiquadFilter();
					filter.type = 'lowpass';
					filter.frequency.setValueAtTime(400, t);
					gain.gain.setValueAtTime(0.1, t);
					gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
					osc.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
					osc.start(t); osc.stop(t + 0.2);
				}, 250);
			},

			stopBGM: function () {
				this.isPlayingBGM = false;
				if (this.bgmTimer) clearInterval(this.bgmTimer);
			}
		};
		window.AudioSys = AudioSys;

		// ç‰¹æ•ˆç³»ç»Ÿ å¤„ç†æ’æ“Šæ™‚ç”¢ç”Ÿçš„ â€œç²‰ç¢â€æ•ˆæœ
		const VFX = {
			particles: [],
			material: new THREE.MeshBasicMaterial({ color: 0xffffff }), // é»˜è®¤ç™½è‰²ï¼Œä¼šè¢«é¡¶ç‚¹é¢œè‰²è¦†ç›–

			// è§¦å‘çˆ†ç‚¸ç‰¹æ•ˆ
			explode: function (pos, color, scale = 1.0) {
				const count = 8; // ç¢ç‰‡æ•°é‡ï¼Œä¸ç”¨å¤ªå¤šï¼Œä¿æŒæ€§èƒ½
				const geo = new THREE.BoxGeometry(0.3 * scale, 0.3 * scale, 0.3 * scale);
				const mat = new THREE.MeshBasicMaterial({ color: color });

				for (let i = 0; i < count; i++) {
					const mesh = new THREE.Mesh(geo, mat);
					mesh.position.copy(pos);

					// éšæœºæ•£å°„é€Ÿåº¦
					mesh.userData = {
						vel: new THREE.Vector3(
							(Math.random() - 0.5) * 15,
							Math.random() * 10 + 5, // å‘ä¸Šç‚¸
							(Math.random() - 0.5) * 15
						),
						life: 1.0 // å­˜æ´»æ—¶é—´
					};

					scene.add(mesh);
					this.particles.push(mesh);
				}
			},

			// æ¯å¸§æ›´æ–°ç²’å­
			update: function (delta) {
				for (let i = this.particles.length - 1; i >= 0; i--) {
					const p = this.particles[i];
					p.userData.life -= delta * 2; // 0.5ç§’åæ¶ˆå¤±

					if (p.userData.life <= 0) {
						scene.remove(p);
						this.particles.splice(i, 1);
					} else {
						// ç‰©ç†æ¨¡æ‹Ÿï¼šé‡åŠ›ä¸‹è½
						p.userData.vel.y -= 30 * delta;
						p.position.add(p.userData.vel.clone().multiplyScalar(delta));
						p.rotation.x += p.userData.vel.z * delta;
						p.rotation.z += p.userData.vel.x * delta;
						p.scale.setScalar(p.userData.life); // æ…¢æ…¢å˜å°
					}
				}
			}
		};

		const GameData = {
			coins: 0,
			inventory: { magnet: 0, jetpack: 0 },
			settings: { autoMagnet: false, autoJetpack: false },
			// V23: New Data for Chars
			unlockedChars: ['default'],
			curChar: 'default',

			load: function () {
				const saved = localStorage.getItem('moonChaser_save');
				if (saved) {
					try {
						const parsed = JSON.parse(saved);
						this.coins = parsed.coins || 0;
						this.inventory = parsed.inventory || { magnet: 0, jetpack: 0 };
						this.settings = parsed.settings || { autoMagnet: false, autoJetpack: false };
						this.unlockedChars = parsed.unlockedChars || ['default'];
						this.curChar = parsed.curChar || 'default';
					} catch (e) { this.coins = CONFIG.INITIAL_COINS; }
				} else {
					this.coins = CONFIG.INITIAL_COINS;
					this.save();
				}
				if (document.getElementById('menu-coin-count')) document.getElementById('menu-coin-count').innerText = this.coins;
			},
			save: function () {
				localStorage.setItem('moonChaser_save', JSON.stringify({
					coins: this.coins,
					inventory: this.inventory,
					settings: this.settings,
					unlockedChars: this.unlockedChars,
					curChar: this.curChar
				}));
			},
			addCoins: function (amount) { this.coins += amount; this.save(); if (document.getElementById('menu-coin-count')) document.getElementById('menu-coin-count').innerText = this.coins; }
		};

		const LANG = {
			en: {
				title: "FREE RUN<br>MOON CHASER",
				play: "TAP TO PLAY", crashed: "CRASHED!", score: "SCORE", tryAgain: "TRY AGAIN", mainMenu: "MAIN MENU",
				controls: `
            <div class="control-row">
                <div><span class="key-cap key-move">â†</span> <span class="key-cap key-move">â†’</span></div>
                <span class="control-label">MOVE</span>
            </div>
            <div class="control-row">
                <div><span class="key-cap key-jump">â†‘</span></div>
                <span class="control-label">JUMP</span>
                <div style="width:15px"></div>
                <div><span class="key-cap key-roll">â†“</span></div>
                <span class="control-label">ROLL</span>
            </div>
            <div class="swipe-hint"><span class="swipe-icon">ğŸ‘†</span> (Swipe on Screen)</div>
        `,
				rankBtn: "LEADERBOARD", lbTitle: "TOP RUNNERS", lbRank: "RANK", lbName: "NAME", lbScore: "SCORE", lbTime: "TIME", lbClose: "CLOSE", lbPlaceholder: "Enter Name", lbSave: "SAVE & RETRY", lbNoRecord: "No records yet.",
				storeBtn: "SUPPLY STORE", storeTitle: "SUPPLY STORE", storeBack: "BACK",
				itemNameMag: "Magnet Start", itemDescMag: "Start run with Magnet", itemOwn: "Owned: ", autoUse: "Auto-Use",
				itemNameJet: "Jetpack Start", itemDescJet: "Start run with Jetpack",
				pauseTitle: "PAUSED", resume: "RESUME", pauseMenu: "MAIN MENU",
				charTitle: "CHARACTERS", charBack: "BACK", owned: "OWNED", equip: "EQUIP", equipped: "EQUIPPED", buy: "BUY"
			},
			cn: {
				title: "è‡ªç”±å¥”è·‘<br>é€æœˆè€…",
				play: "ç‚¹å‡»å¼€å§‹", crashed: "æ’å‡»!", score: "æœ€ç»ˆå¾—åˆ†", tryAgain: "å†æ¥ä¸€æ¬¡", mainMenu: "è¿”å›ä¸»èœå•",
				controls: `
            <div class="control-row">
                <div><span class="key-cap key-move">â†</span> <span class="key-cap key-move">â†’</span></div>
                <span class="control-label">å·¦å³å˜é“</span>
            </div>
            <div class="control-row">
                <div><span class="key-cap key-jump">â†‘</span></div>
                <span class="control-label">è·³è·ƒ</span>
                <div style="width:15px"></div>
                <div><span class="key-cap key-roll">â†“</span></div>
                <span class="control-label">ç¿»æ»š</span>
            </div>
            <div class="swipe-hint"><span class="swipe-icon">ğŸ‘†</span> (æ‰‹æœºç«¯æ”¯æŒæ»‘åŠ¨æ“ä½œ)</div>
        `,
				rankBtn: "æ’è¡Œæ¦œ", lbTitle: "é¡¶çº§å¥”è·‘è€…", lbRank: "æ’å", lbName: "åå­—", lbScore: "åˆ†æ•°", lbTime: "æ—¶é•¿", lbClose: "å…³é—­", lbPlaceholder: "è¾“å…¥åå­—", lbSave: "ä¿å­˜å¹¶é‡è¯•", lbNoRecord: "æš‚æ— è®°å½•ï¼Œå¿«å»ç©ä¸€æŠŠï¼",
				storeBtn: "è¡¥ç»™å•†åº—", storeTitle: "è¡¥ç»™å•†åº—", storeBack: "è¿”å›",
				itemNameMag: "å¼€å±€ç£é“", itemDescMag: "å¼€å±€è‡ªåŠ¨æ¿€æ´»ç£é“", itemOwn: "æ‹¥æœ‰: ", autoUse: "è‡ªåŠ¨ä½¿ç”¨",
				itemNameJet: "å¼€å±€é£è¡Œ", itemDescJet: "å¼€å±€è‡ªåŠ¨ä½¿ç”¨å–·æ°”èƒŒåŒ…",
				pauseTitle: "æ¸¸æˆæš‚åœ", resume: "ç»§ç»­æ¸¸æˆ", pauseMenu: "è¿”å›ä¸»èœå•",
				charTitle: "è§’è‰²é€‰æ‹©", charBack: "è¿”å›", owned: "å·²æ‹¥æœ‰", equip: "è£…å¤‡", equipped: "ä½¿ç”¨ä¸­", buy: "è´­ä¹°"
			}
		};

		// å¦‚æœæµè§ˆå™¨è¯­è¨€æ˜¯ zh-CN æˆ– zh-TW ç­‰ï¼Œé»˜è®¤ç”¨ cnï¼Œå¦åˆ™ç”¨ en
		let currentLang = navigator.language.startsWith('zh') ? 'cn' : 'en';

		let scene, camera, renderer, clock;
		let player;
		let gameActive = false;
		let isPaused = false;
		let score = 0, coins = 0, distance = 0, survivalTime = 0;
		let speed = CONFIG.PLAYER_SPEED_BASE;

		let hasShield = false;      // æ˜¯å¦æ‹¥æœ‰æŠ¤ç›¾
		let isInvincible = false;   // æ˜¯å¦å¤„äºæ— æ•ŒçŠ¶æ€
		let invincibleTimer = 0;    // æ— æ•Œå€’è®¡æ—¶

		// Environment references
		let ambientLight, dirLight, sunMesh;
		let cycleTime = CONFIG.CYCLE_DURATION * CONFIG.START_TIME_OFFSET;

		const activeTracks = [];
		const activeObstacles = [];
		const activeCoins = [];
		const activeMagnets = [];
		const activeJetpacks = [];
		const activeDecorations = [];
		let world = { lastSpawnZ: 0 };

		let targetLane = 1;
		let isJumping = false, isSliding = false;
		let verticalVelocity = 0, slideTimer = 0;
		let magnetActive = false, magnetTimer = 0;
		let jetpackActive = false, jetpackTimer = 0;

		// Materials
		let buildingMaterials = [];
		let trainBodyMat, trainWindowMat, trainWheelMat;

		function init() {
			document.getElementById('loading').style.display = 'none';
			GameData.load();
			scene = new THREE.Scene();
			scene.background = new THREE.Color(CONFIG.COLORS.skyNight);
			scene.fog = new THREE.Fog(CONFIG.COLORS.skyNight, 20, 120);
			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 300);
			camera.position.set(0, 4, 10);
			camera.rotation.set(-0.1, 0, 0);
			renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			document.getElementById('game-container').appendChild(renderer.domElement);

			createBuildingMaterials();
			createTrainMaterials();
			createEnvironment();
			createPlayerModel();
			CloudSystem.init(scene);
			setupInputs();
			setupUI();
			clock = new THREE.Clock();
			animate();
		}

		function createBuildingMaterials() {
			const colors = [0x2ecc71, 0x3498db, 0x9b59b6, 0xf1c40f, 0xe67e22];
			colors.forEach(col => {
				const canvas = document.createElement('canvas');
				canvas.width = 64; canvas.height = 64;
				const ctx = canvas.getContext('2d');
				ctx.fillStyle = '#' + new THREE.Color(col).getHexString();
				ctx.fillRect(0, 0, 64, 64);
				ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
				for (let y = 10; y < 64; y += 16) { for (let x = 8; x < 64; x += 16) { if (Math.random() > 0.3) ctx.fillRect(x, y, 8, 10); } }
				const texture = new THREE.CanvasTexture(canvas); texture.magFilter = THREE.NearestFilter;
				buildingMaterials.push(new THREE.MeshPhongMaterial({ map: texture, color: 0xaaaaaa, emissive: col, emissiveIntensity: 0.2, shininess: 30 }));
			});
		}

		function createTrainMaterials() {
			trainBodyMat = new THREE.MeshPhongMaterial({ color: 0x34495e, shininess: 80, reflectivity: 0.5 });
			const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 32;
			const ctx = canvas.getContext('2d'); ctx.fillStyle = '#f1c40f'; ctx.fillRect(0, 5, 64, 22);
			const texture = new THREE.CanvasTexture(canvas); texture.magFilter = THREE.NearestFilter;
			trainWindowMat = new THREE.MeshBasicMaterial({ map: texture, color: 0xffffff });
			trainWheelMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
		}

		function createTrainModel(isMoving) {
			const group = new THREE.Group();
			const body = new THREE.Mesh(new THREE.BoxGeometry(2.6, 3.5, 18), trainBodyMat);
			body.position.y = 2.25; body.castShadow = true; group.add(body);
			const windows = new THREE.Mesh(new THREE.BoxGeometry(2.65, 1.0, 16), trainWindowMat);
			windows.position.y = 3.0; group.add(windows);
			const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 3, 16); wheelGeo.rotateZ(Math.PI / 2);
			[-6, -2, 2, 6].forEach(z => { const axle = new THREE.Mesh(wheelGeo, trainWheelMat); axle.position.set(0, 0.6, z); axle.castShadow = true; group.add(axle); });
			if (isMoving) {
				const lightGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 16); lightGeo.rotateX(Math.PI / 2);
				const lightMesh = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 1 }));
				lightMesh.position.set(0, 2, 9.1); group.add(lightMesh);
			}
			group.userData.isObstacle = true;
			if (isMoving) { group.userData.isMovingTrain = true; group.userData.trainSpeed = 35; }
			return group;
		}

		// ==========================================
		//   å®šä¹‰è§’è‰²æ„å»ºå™¨ (Character Builders)
		// ==========================================

		// æè´¨ç¼“å­˜ï¼ˆä¼˜åŒ–æ€§èƒ½ï¼Œé¿å…é‡å¤åˆ›å»ºæè´¨ï¼‰
		const Materials = {
			standard: (col) => new THREE.MeshPhongMaterial({ color: col, shininess: 30, flatShading: false }),
			plastic: (col) => new THREE.MeshLambertMaterial({ color: col }),
			glow: (col) => new THREE.MeshBasicMaterial({ color: col }),
			metal: (col) => new THREE.MeshStandardMaterial({ color: col, roughness: 0.3, metalness: 0.8 }),
			dark: new THREE.MeshPhongMaterial({ color: 0x2c3e50, shininess: 10 })
		};

		// è§’è‰²å·¥å‚
		const CharacterFactory = {
			// åŸºç¡€éª¨æ¶æ„å»ºï¼ˆä¸ºäº†ä¿è¯åŠ¨ç”»é€šç”¨æ€§ï¼Œæ‰€æœ‰è§’è‰²åŸºäºæ­¤ç»“æ„æ‰©å±•ï¼‰
			createBaseSkeleton: function () {
				const group = new THREE.Group();
				// è¿™é‡Œçš„ userData æ˜¯æ¥å£çš„å…³é”®ï¼ŒåŠ¨ç”»å¾ªç¯åªè®¤è¿™äº›åå­—
				group.userData = { head: null, lArm: null, rArm: null, lLeg: null, rLeg: null, pack: null, flames: [] };
				return group;
			},

			// 1. é»˜è®¤è§’è‰²ï¼šèµ›åšè·‘è€… (Runner)
			buildDefault: function (color, glowColor) {
				const player = this.createBaseSkeleton();

				// å¤´ç›” (å¸¦é¢ç½©)
				const headG = new THREE.Group();
				const headMesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.55, 0.6), Materials.standard(color));
				const visor = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.2, 0.4), Materials.glow(glowColor));
				visor.position.set(0, 0.05, 0.15);
				headG.add(headMesh, visor);
				headG.position.y = 1.5;
				player.add(headG); player.userData.head = headG;

				// èº«ä½“
				const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.35), Materials.standard(color));
				body.position.y = 0.85;
				player.add(body);

				// å››è‚¢ (ä½¿ç”¨æ›´åœ†æ¶¦çš„å‡ ä½•ä½“æ¯”å‚è€ƒå›¾æ›´å¥½çœ‹)
				const limbGeo = new THREE.BoxGeometry(0.18, 0.55, 0.18);
				const limbMat = Materials.dark;

				const lArm = new THREE.Mesh(limbGeo, limbMat); lArm.position.set(-0.38, 1.0, 0);
				const rArm = new THREE.Mesh(limbGeo, limbMat); rArm.position.set(0.38, 1.0, 0);
				const lLeg = new THREE.Mesh(limbGeo, Materials.standard(color)); lLeg.position.set(-0.15, 0.3, 0);
				const rLeg = new THREE.Mesh(limbGeo, Materials.standard(color)); rLeg.position.set(0.15, 0.3, 0);

				player.add(lArm, rArm, lLeg, rLeg);
				Object.assign(player.userData, { lArm, rArm, lLeg, rLeg }); // ç»‘å®šéª¨éª¼

				return player;
			},

			// 2. çº¢è‰²è§’è‰²ï¼šæ­¦å£« (Samurai - æ›´æœ‰æ£±è§’)
			buildCrimson: function (color, glowColor) {
				const player = this.createBaseSkeleton();

				// æ­¦å£«å¤´ç›”
				const headG = new THREE.Group();
				const helmet = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.4, 0.5, 4), Materials.standard(color));
				const hornL = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.3, 4), Materials.glow(glowColor));
				hornL.position.set(-0.25, 0.2, 0); hornL.rotation.z = 0.5;
				const hornR = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.3, 4), Materials.glow(glowColor));
				hornR.position.set(0.25, 0.2, 0); hornR.rotation.z = -0.5;
				headG.add(helmet, hornL, hornR);
				headG.position.y = 1.5;
				player.add(headG); player.userData.head = headG;

				// ç›”ç”²èº«ä½“
				const body = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.25, 0.7, 6), Materials.standard(0x2c3e50));
				body.position.y = 0.85;
				player.add(body);

				// å¼ºå£®çš„å››è‚¢
				const armGeo = new THREE.BoxGeometry(0.2, 0.6, 0.2);
				const lArm = new THREE.Mesh(armGeo, Materials.standard(color)); lArm.position.set(-0.4, 1.0, 0);
				const rArm = new THREE.Mesh(armGeo, Materials.standard(color)); rArm.position.set(0.4, 1.0, 0);
				const lLeg = new THREE.Mesh(armGeo, Materials.standard(0x111111)); lLeg.position.set(-0.15, 0.3, 0);
				const rLeg = new THREE.Mesh(armGeo, Materials.standard(0x111111)); rLeg.position.set(0.15, 0.3, 0);

				player.add(lArm, rArm, lLeg, rLeg);
				Object.assign(player.userData, { lArm, rArm, lLeg, rLeg });

				return player;
			},

			// 3. éšå½¢è§’è‰²ï¼šå¿è€… (Stealth - çº¤ç»†ï¼Œæµçº¿å‹)
			buildStealth: function (color, glowColor) {
				const player = this.createBaseSkeleton();

				// å¿è€…å¤´å·¾
				const headG = new THREE.Group();
				const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 16, 16), Materials.standard(color));
				const eye = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.05, 0.2), Materials.glow(glowColor));
				eye.position.set(0, 0, 0.2);
				// é£˜å¸¦ (é™æ€)
				const scarf = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.05), Materials.standard(0xff0000));
				scarf.position.set(0, -0.2, -0.3); scarf.rotation.x = 0.5;
				headG.add(head, eye, scarf);
				headG.position.y = 1.5;
				player.add(headG); player.userData.head = headG;

				// ç´§èº«è¡£
				const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.25, 0.5, 4, 8), Materials.standard(0x1a1a1a));
				body.position.y = 0.9;
				player.add(body);

				// çº¤ç»†å››è‚¢
				const limbGeo = new THREE.CylinderGeometry(0.08, 0.06, 0.6, 8);
				const lArm = new THREE.Mesh(limbGeo, Materials.standard(0x333333)); lArm.position.set(-0.32, 1.05, 0);
				const rArm = new THREE.Mesh(limbGeo, Materials.standard(0x333333)); rArm.position.set(0.32, 1.05, 0);
				const lLeg = new THREE.Mesh(limbGeo, Materials.standard(0x333333)); lLeg.position.set(-0.12, 0.3, 0);
				const rLeg = new THREE.Mesh(limbGeo, Materials.standard(0x333333)); rLeg.position.set(0.12, 0.3, 0);

				player.add(lArm, rArm, lLeg, rLeg);
				Object.assign(player.userData, { lArm, rArm, lLeg, rLeg });
				return player;
			},

			// 4. é»„é‡‘è§’è‰²ï¼šæœºå™¨äºº (Bot - ç±»ä¼¼å‚è€ƒå›¾ä½†æ›´ç²¾è‡´)
			buildGolden: function (color, glowColor) {
				const player = this.createBaseSkeleton();

				// æœºå™¨äººåœ†å¤´
				const headG = new THREE.Group();
				const dome = new THREE.Mesh(new THREE.SphereGeometry(0.3, 32, 32), Materials.metal(color));
				const antenna = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.3), Materials.standard(0x888888));
				antenna.position.y = 0.3;
				headG.add(dome, antenna);
				headG.position.y = 1.5;
				player.add(headG); player.userData.head = headG;

				// æ–¹å—èº«ä½“ (è‡´æ•¬å‚è€ƒå›¾)
				const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.4), Materials.metal(color));
				body.position.y = 0.9;
				player.add(body);

				// å…³èŠ‚è¿æ¥çš„å››è‚¢ (çƒå½¢å…³èŠ‚ + åœ†æŸ±)
				const jointGeo = new THREE.SphereGeometry(0.12, 16, 16);
				const limbGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.45, 16);

				// æ„å»ºå¸¦å…³èŠ‚çš„æ‰‹è‡‚è¾…åŠ©å‡½æ•°
				const createLimb = (x, y, isLeg) => {
					const g = new THREE.Group();
					g.position.set(x, y, 0);
					const joint = new THREE.Mesh(jointGeo, Materials.standard(0x555555));
					const limb = new THREE.Mesh(limbGeo, Materials.metal(color));
					limb.position.y = isLeg ? -0.25 : -0.25;
					g.add(joint, limb);
					return g;
				};

				const lArm = createLimb(-0.4, 1.1, false);
				const rArm = createLimb(0.4, 1.1, false);
				const lLeg = createLimb(-0.2, 0.5, true);
				const rLeg = createLimb(0.2, 0.5, true);

				player.add(lArm, rArm, lLeg, rLeg);
				Object.assign(player.userData, { lArm, rArm, lLeg, rLeg });

				return player;
			}
		};

		const CoinFactory = {
			// åŸºç¡€é‡‘å¸æè´¨ç¼“å­˜
			materials: {
				gold: new THREE.MeshPhongMaterial({ color: 0xFFD700, shininess: 100, specular: 0xFFFFFF }),
				gem: new THREE.MeshPhongMaterial({ color: 0x00FFFF, shininess: 150, emissive: 0x004444 }),
				starCore: new THREE.MeshPhongMaterial({ color: 0xE74C3C, shininess: 100, emissive: 0x330000 }),
				starRing: new THREE.MeshBasicMaterial({ color: 0xFFD700 })
			},

			// åˆ›å»ºæ™®é€šé‡‘å¸ (åœ†æŸ±ä½“)
			createNormal: function () {
				const geo = new THREE.CylinderGeometry(0.35, 0.35, 0.1, 16);
				geo.rotateZ(Math.PI / 2);
				const mesh = new THREE.Mesh(geo, this.materials.gold);
				mesh.userData = { type: 'normal', value: 1, rotateSpeed: 0.1 };
				return mesh;
			},

			// åˆ›å»ºè“é’»å¸ (å…«é¢ä½“) - ä»·å€¼ 50
			createGem: function () {
				// ä½¿ç”¨å…«é¢ä½“æ¨¡æ‹Ÿé’»çŸ³
				const geo = new THREE.OctahedronGeometry(0.45, 0);
				const mesh = new THREE.Mesh(geo, this.materials.gem);

				// æ·»åŠ ä¸€ä¸ªå‘å…‰çš„å†…éƒ¨çº¿æ¡†ï¼Œå¢åŠ ç§‘æŠ€æ„Ÿ
				const wireGeo = new THREE.WireframeGeometry(geo);
				const wireMat = new THREE.LineBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.5 });
				const wireframe = new THREE.LineSegments(wireGeo, wireMat);
				mesh.add(wireframe);

				mesh.userData = { type: 'gem', value: CONFIG.SPECIAL_COINS.gem.value, rotateSpeed: CONFIG.SPECIAL_COINS.gem.rotateSpeed };
				return mesh;
			},

			// åˆ›å»ºç´«æ˜Ÿå¸ (å¸¦ç¯çƒä½“) - ä»·å€¼ 100
			createStar: function () {
				const group = new THREE.Group();

				// æ ¸å¿ƒçƒä½“
				const coreGeo = new THREE.IcosahedronGeometry(0.4, 1);
				const core = new THREE.Mesh(coreGeo, this.materials.starCore);
				group.add(core);

				// å¤–éƒ¨æ˜Ÿç¯ (Torus)
				const ringGeo = new THREE.TorusGeometry(0.6, 0.05, 8, 32);
				ringGeo.rotateX(Math.PI / 2); //ä»¥æ­¤è®©ç¯æ°´å¹³
				const ring = new THREE.Mesh(ringGeo, this.materials.starRing);
				group.add(ring);

				// æ ‡è®° group ä¸ºå¯äº¤äº’å¯¹è±¡ï¼Œå¹¶ä¿å­˜ç¯çš„å¼•ç”¨ä»¥ä¾¿æ—‹è½¬
				group.userData = {
					type: 'star',
					value: CONFIG.SPECIAL_COINS.star.value,
					rotateSpeed: CONFIG.SPECIAL_COINS.star.rotateSpeed,
					isGroup: true,
					ring: ring
				};
				return group;
			}
		};

		// äº‘ç³»ç»Ÿ
		const CloudSystem = {
			clouds: [],
			material: null, // å…±äº«æè´¨ï¼Œç”¨äºç»Ÿä¸€å˜è‰²

			init: function (scene) {
				// ä½¿ç”¨ FlatShading çš„æè´¨ï¼Œé…åˆä½å¤šè¾¹å½¢é£æ ¼
				this.material = new THREE.MeshPhongMaterial({
					color: 0xffffff,
					shininess: 0,
					flatShading: true,
					transparent: true,
					opacity: 0.9
				});

				for (let i = 0; i < CONFIG.CLOUDS.count; i++) {
					const cloud = this.createCloud();
					// éšæœºåˆ†å¸ƒ
					cloud.position.set(
						(Math.random() - 0.5) * CONFIG.CLOUDS.rangeX,
						CONFIG.CLOUDS.minHeight + Math.random() * (CONFIG.CLOUDS.maxHeight - CONFIG.CLOUDS.minHeight),
						-Math.random() * CONFIG.CLOUDS.depth
					);

					// ç»™äºˆæ¯æœµäº‘ç‹¬ç‰¹çš„æ¼‚æµ®å‚æ•°
					cloud.userData = {
						speedOffset: 1 + Math.random() * 0.5, // é€Ÿåº¦å¾®å·®
						bobSpeed: 0.5 + Math.random() * 0.5,  // ä¸Šä¸‹æµ®åŠ¨é€Ÿåº¦
						bobAmp: 0.5 + Math.random(),          // ä¸Šä¸‹æµ®åŠ¨å¹…åº¦
						rotSpeed: (Math.random() - 0.5) * 0.2 // è‡ªè½¬é€Ÿåº¦
					};

					scene.add(cloud);
					this.clouds.push(cloud);
				}
			},

			createCloud: function () {
				const group = new THREE.Group();

				// æ¯ä¸€æœµäº‘ç”± 3-6 ä¸ªâ€œäº‘æ³¡â€ç»„æˆ
				const puffs = 3 + Math.floor(Math.random() * 4);
				const geom = new THREE.IcosahedronGeometry(1, 0); // ä½å¤šè¾¹å½¢çƒä½“

				for (let i = 0; i < puffs; i++) {
					const mesh = new THREE.Mesh(geom, this.material);

					// éšæœºå¤§å°
					const scale = 3 + Math.random() * 5;
					mesh.scale.set(scale, scale, scale);

					// éšæœºä½ç½® (èšæ‹¢åœ¨ä¸€èµ·)
					mesh.position.set(
						(Math.random() - 0.5) * 6,
						(Math.random() - 0.5) * 3,
						(Math.random() - 0.5) * 4
					);

					// éšæœºæ—‹è½¬
					mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);

					mesh.castShadow = false; // äº‘é€šå¸¸ä¸æŠ•å°„ç”Ÿç¡¬çš„é˜´å½±ï¼Œæˆ–è€…ä½ å¯ä»¥å¼€å¯ receiveShadow
					group.add(mesh);
				}
				return group;
			},

			update: function (delta, playerZ) {
				const time = Date.now() * 0.001;

				this.clouds.forEach(cloud => {
					// 1. ç§»åŠ¨é€»è¾‘ï¼šäº‘æœµå‘åé£˜ï¼Œäº§ç”Ÿè§†å·®
					// è¿™é‡Œçš„é€Ÿåº¦æ˜¯ CONFIG.speed åŠ ä¸Šä¸€ç‚¹éšæœºï¼Œå†å‡å»ç©å®¶çš„é€Ÿåº¦(æ¨¡æ‹Ÿç›¸å¯¹è¿åŠ¨)
					// ä½†ä¸ºäº†ç¾è§‚ï¼Œé€šå¸¸æˆ‘ä»¬è®©äº‘æ…¢é€Ÿå‘åé£˜å³å¯ï¼Œä¸å®Œå…¨ç»‘å®šç©å®¶é€Ÿåº¦ï¼Œå¦åˆ™çœ‹èµ·æ¥åƒèƒŒæ™¯æ¿
					cloud.position.z += CONFIG.CLOUDS.speed * cloud.userData.speedOffset * delta;

					// 2. å¾ªç¯åˆ©ç”¨ï¼šå¦‚æœè·‘å¤ªè¿œäº†ï¼ŒæŒªå›æœ€å‰é¢
					if (cloud.position.z > playerZ + 50) {
						cloud.position.z = playerZ - CONFIG.CLOUDS.depth;
						cloud.position.x = (Math.random() - 0.5) * CONFIG.CLOUDS.rangeX;
						cloud.position.y = CONFIG.CLOUDS.minHeight + Math.random() * (CONFIG.CLOUDS.maxHeight - CONFIG.CLOUDS.minHeight);
					}

					// 3. åŠ¨æ€æ•ˆæœï¼šä¸Šä¸‹æµ®åŠ¨
					cloud.position.y += Math.sin(time * cloud.userData.bobSpeed) * 0.02;

					// 4. ç¼“æ…¢è‡ªè½¬
					cloud.rotation.y += cloud.userData.rotSpeed * delta;
				});
			},

			// æ˜¼å¤œå¾ªç¯é¢œè‰²æ›´æ–°
			updateColor: function (progress) {
				let cloudColor;
				// ç®€å•çš„çº¿æ€§æ’å€¼æ¥å†³å®šäº‘çš„é¢œè‰²
				if (progress < 0.2) { // æ—¥å‡º (æš— -> æ©™)
					const t = progress / 0.2;
					cloudColor = new THREE.Color(0x222244).lerp(new THREE.Color(0xFFAA88), t);
				} else if (progress < 0.5) { // ç™½å¤© (æ©™ -> ç™½)
					const t = (progress - 0.2) / 0.3;
					cloudColor = new THREE.Color(0xFFAA88).lerp(new THREE.Color(0xFFFFFF), t);
				} else if (progress < 0.7) { // æ—¥è½ (ç™½ -> ç´«çº¢)
					const t = (progress - 0.5) / 0.2;
					cloudColor = new THREE.Color(0xFFFFFF).lerp(new THREE.Color(0xFF88AA), t);
				} else { //å“ªæ€• (ç´«çº¢ -> æš—è“)
					const t = (progress - 0.7) / 0.3;
					cloudColor = new THREE.Color(0xFF88AA).lerp(new THREE.Color(0x111122), t);
				}

				if (this.material) {
					this.material.color.copy(cloudColor);
					// å¤œæ™šç¨å¾®é€æ˜ä¸€ç‚¹
					this.material.opacity = (progress > 0.8 || progress < 0.1) ? 0.6 : 0.9;
				}
			}
		};

		// ==========================================
		//    æ ¸å¿ƒæ›¿æ¢å‡½æ•°ï¼šcreatePlayerModel
		// ==========================================

		function createPlayerModel() {
			if (player) scene.remove(player); // æ¸…é™¤æ—§æ¨¡å‹

			// è·å–å½“å‰é€‰æ‹©çš„è§’è‰²ID
			const charId = GameData.curChar || 'default';
			const charData = CHARACTERS[charId];

			// æ ¹æ®IDè°ƒç”¨ä¸åŒçš„æ„å»ºå·¥å‚
			let newPlayer;
			switch (charId) {
				case 'crimson':
					newPlayer = CharacterFactory.buildCrimson(charData.color, charData.glow);
					break;
				case 'stealth':
					newPlayer = CharacterFactory.buildStealth(charData.color, charData.glow);
					break;
				case 'golden':
					newPlayer = CharacterFactory.buildGolden(charData.color, charData.glow);
					break;
				default:
					newPlayer = CharacterFactory.buildDefault(charData.color, charData.glow);
					break;
			}

			// --- é€šç”¨é…ä»¶ï¼šå–·æ°”èƒŒåŒ… (Jetpack) ---
			// æ‰€æœ‰è§’è‰²å…±ç”¨è¿™å¥—é€»è¾‘ï¼ŒæŒ‚è½½åœ¨èƒŒéƒ¨
			const pack = new THREE.Group();
			const packBody = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.2), Materials.dark);
			pack.add(packBody);

			// å–·å£
			const nozzleGeo = new THREE.CylinderGeometry(0.06, 0.1, 0.2, 8);
			const nozzleL = new THREE.Mesh(nozzleGeo, Materials.dark); nozzleL.position.set(-0.12, -0.3, 0);
			const nozzleR = new THREE.Mesh(nozzleGeo, Materials.dark); nozzleR.position.set(0.12, -0.3, 0);
			pack.add(nozzleL, nozzleR);

			// ç«ç„°ç²’å­ (é¢„åˆ›å»º)
			const flameGeo = new THREE.ConeGeometry(0.12, 0.8, 8);
			flameGeo.translate(0, 0.4, 0);
			const matFire = new THREE.MeshBasicMaterial({ color: 0xFF6600 });
			const flameL = new THREE.Mesh(flameGeo, matFire);
			flameL.rotation.x = Math.PI; flameL.position.set(-0.12, -0.4, 0);
			const flameR = new THREE.Mesh(flameGeo, matFire);
			flameR.rotation.x = Math.PI; flameR.position.set(0.12, -0.4, 0);
			pack.add(flameL, flameR);

			pack.position.set(0, 1.0, -0.25); // æŒ‚åœ¨èƒŒéƒ¨
			pack.visible = false; // é»˜è®¤éšè—

			// å°†èƒŒåŒ…ç»„ä»¶æ³¨å…¥åˆ° newPlayer çš„ userData ä¸­ï¼Œä¿è¯åŸæœ‰é€»è¾‘ä¸æŠ¥é”™
			newPlayer.add(pack);
			newPlayer.userData.pack = pack;
			newPlayer.userData.flames = [flameL, flameR];

			// é˜´å½±è®¾ç½®
			newPlayer.traverse(obj => { if (obj.isMesh) obj.castShadow = true; });

			player = newPlayer;
			scene.add(player);
		}

		function createMagnetModel() {
			const group = new THREE.Group();
			const matRed = new THREE.MeshPhongMaterial({ color: 0xE74C3C });
			const matSilver = new THREE.MeshPhongMaterial({ color: 0xBDC3C7 });
			const bottom = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.15, 0.15), matRed); bottom.position.y = -0.25;
			const left = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), matRed); left.position.set(-0.225, 0, 0);
			const right = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), matRed); right.position.set(0.225, 0, 0);
			const tipL = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.15, 0.16), matSilver); tipL.position.set(-0.225, 0.25, 0);
			const tipR = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.15, 0.16), matSilver); tipR.position.set(0.225, 0.25, 0);
			group.add(bottom, left, right, tipL, tipR);
			const wrapper = new THREE.Group(); wrapper.add(group);
			wrapper.scale.set(1.5, 1.5, 1.5); wrapper.userData = { type: 'MAGNET', rotate: true };
			return wrapper;
		}

		function createJetpackModel() {
			const group = new THREE.Group();
			const matTank = new THREE.MeshPhongMaterial({ color: 0x95a5a6, shininess: 80 });
			const matDetail = new THREE.MeshLambertMaterial({ color: 0xf1c40f });
			const tankGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.6, 12);
			const tankL = new THREE.Mesh(tankGeo, matTank); tankL.position.x = -0.2;
			const tankR = new THREE.Mesh(tankGeo, matTank); tankR.position.x = 0.2;
			const belt = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.1, 0.15), matDetail);
			group.add(tankL, tankR, belt);
			const wrapper = new THREE.Group(); wrapper.add(group);
			wrapper.scale.set(1.5, 1.5, 1.5); wrapper.userData = { type: 'JETPACK', rotate: true };
			return wrapper;
		}

		function createEnvironment() {
			// Lights
			ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
			scene.add(ambientLight);
			dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
			dirLight.position.set(-10, 30, 20); dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 1024; dirLight.shadow.mapSize.height = 1024;
			dirLight.shadow.camera.near = 0.5; dirLight.shadow.camera.far = 100;
			scene.add(dirLight);

			// Sun/Moon
			sunMesh = new THREE.Mesh(new THREE.SphereGeometry(25, 32, 32), new THREE.MeshBasicMaterial({ color: 0xFFFFDD }));
			sunMesh.position.set(20, 40, -120);
			scene.add(sunMesh);

			for (let i = 0; i < 3; i++) createTrackSegment(-i * CONFIG.TRACK_LENGTH);
		}

		function createTrackSegment(zPos) {
			const seg = new THREE.Group();
			const floor = new THREE.Mesh(new THREE.PlaneGeometry(60, CONFIG.TRACK_LENGTH), new THREE.MeshPhongMaterial({ color: CONFIG.COLORS.ground }));
			floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true;
			seg.add(floor);
			const rGeo = new THREE.BoxGeometry(0.2, 0.1, CONFIG.TRACK_LENGTH);
			const rMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
			CONFIG.LANES.forEach(x => {
				let r1 = new THREE.Mesh(rGeo, rMat); r1.position.set(x - 1.0, 0.05, 0); seg.add(r1);
				let r2 = new THREE.Mesh(rGeo, rMat); r2.position.set(x + 1.6, 0.05, 0); seg.add(r2);
			});
			seg.position.z = zPos;
			scene.add(seg);
			activeTracks.push(seg);
		}

		function spawnBuilding(zPos) {
			const h1 = 15 + Math.random() * 30; const w1 = 5 + Math.random() * 5; const d1 = 5 + Math.random() * 5;
			const mat1 = buildingMaterials[Math.floor(Math.random() * buildingMaterials.length)];
			const b1 = new THREE.Mesh(new THREE.BoxGeometry(w1, h1, d1), mat1);
			b1.position.set(-12 - (w1 / 2), h1 / 2 - 5, zPos); b1.castShadow = true; b1.receiveShadow = true;
			scene.add(b1); activeDecorations.push(b1);

			const h2 = 15 + Math.random() * 30; const w2 = 5 + Math.random() * 5; const d2 = 5 + Math.random() * 5;
			const mat2 = buildingMaterials[Math.floor(Math.random() * buildingMaterials.length)];
			const b2 = new THREE.Mesh(new THREE.BoxGeometry(w2, h2, d2), mat2);
			b2.position.set(12 + (w2 / 2), h2 / 2 - 5, zPos); b2.castShadow = true; b2.receiveShadow = true;
			scene.add(b2); activeDecorations.push(b2);
		}

		function spawnObstacle(zPos) {
			if (jetpackActive) { for (let i = 0; i < 3; i++) spawnCoins(CONFIG.LANES[i], zPos, CONFIG.JETPACK_HEIGHT); }
			const rand = Math.random();
			const laneIdx = Math.floor(Math.random() * 3);
			const laneX = CONFIG.LANES[laneIdx];
			const now = Date.now();

			if (rand < 0.05) {
				const mag = createMagnetModel(); mag.position.set(laneX, 1.0, zPos); scene.add(mag); activeMagnets.push(mag);
			} else if (rand < 0.10) {
				const jet = createJetpackModel(); jet.position.set(laneX, 1.0, zPos); scene.add(jet); activeJetpacks.push(jet);
			} else {
				let mesh;
				const obstacleType = Math.random();
				let canSpawnTrain = (now - world.lastMovingTrainTime) > CONFIG.TRAIN_COOLDOWN;

				if (canSpawnTrain && obstacleType < 0.25) {
					mesh = createTrainModel(true);
					mesh.position.set(laneX, 0, zPos - CONFIG.MOVING_TRAIN_SPAWN_OFFSET);
					world.lastMovingTrainTime = now;
				} else if (obstacleType < 0.6) {
					mesh = createTrainModel(false); mesh.position.set(laneX, 0, zPos);
				} else if (obstacleType < 0.8) {
					const group = new THREE.Group();
					const pole = new THREE.Mesh(new THREE.BoxGeometry(0.2, 3, 0.2), new THREE.MeshLambertMaterial({ color: 0x7F8C8D }));
					const p1 = pole.clone(); p1.position.set(-1.2, 1.5, 0); const p2 = pole.clone(); p2.position.set(1.2, 1.5, 0);
					const bar = new THREE.Mesh(new THREE.BoxGeometry(2.6, 1, 0.2), new THREE.MeshLambertMaterial({ color: 0x27AE60 }));
					bar.position.set(0, 2.5, 0); group.add(p1, p2, bar); group.position.set(laneX, 0, zPos);
					mesh = group; mesh.userData.isHigh = true;
				} else {
					mesh = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.8, 0.5), new THREE.MeshLambertMaterial({ color: 0xE67E22 }));
					mesh.position.set(laneX, 0.4, zPos);
				}
				if (mesh.isMesh || mesh.isGroup) {
					mesh.traverse(child => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; } });
				}
				scene.add(mesh); activeObstacles.push(mesh);
			}

			if (!jetpackActive) { const coinLane = (laneIdx + 1) % 3; spawnCoins(CONFIG.LANES[coinLane], zPos, 0.8); }
			spawnBuilding(zPos);
		}

		function spawnCoins(x, z, height) {
			if (Math.random() > 0.6) return; // åŸºç¡€ç”Ÿæˆæ¦‚ç‡ä¸å˜

			const rand = Math.random();

			// 3% æ¦‚ç‡ç”Ÿæˆ ç´«æ˜Ÿå¸ (ä»·å€¼100)
			if (rand < CONFIG.SPECIAL_COINS.star.chance) {
				const coin = CoinFactory.createStar();
				// ç‰¹æ®Šé‡‘å¸é€šå¸¸æ”¾å¾—ç¨å¾®é«˜ä¸€ç‚¹ï¼Œæˆ–è€…å±…ä¸­
				coin.position.set(x, height + 0.5, z + 3);
				coin.userData.collected = false;
				scene.add(coin);
				activeCoins.push(coin);
				return;
			}

			// 8% æ¦‚ç‡ç”Ÿæˆ è“é’»å¸ (ä»·å€¼50)
			if (rand < CONFIG.SPECIAL_COINS.star.chance + CONFIG.SPECIAL_COINS.gem.chance) {
				const coin = CoinFactory.createGem();
				coin.position.set(x, height + 0.5, z + 3);
				coin.userData.collected = false;
				scene.add(coin);
				activeCoins.push(coin);
				return;
			}

			// å‰©ä¸‹çš„æ¦‚ç‡ç”Ÿæˆ 5ä¸ªæ™®é€šé‡‘å¸ (åŸæœ‰é€»è¾‘)
			for (let i = 0; i < 5; i++) {
				const coin = CoinFactory.createNormal();
				coin.position.set(x, height, z + (i * 1.5));
				coin.userData.collected = false;
				scene.add(coin);
				activeCoins.push(coin);
			}
		}

		function startGame(e) {
			if (e && e.stopPropagation) e.stopPropagation();
			if (document.getElementById('play-btn')) document.getElementById('play-btn').blur();

			// æ’­æ”¾BGM
			AudioSys.init();
			AudioSys.startBGM();

			// é‡ç½®æŠ¤ç›¾çŠ¶æ€
			hasShield = true;       // å¼€å±€è‡ªå¸¦ä¸€æ¬¡æœºä¼š
			isInvincible = false;
			invincibleTimer = 0;

			// ç¡®ä¿ç©å®¶æ¨¡å‹æ˜¯å¯è§çš„ (é˜²æ­¢ä¸Šä¸€å±€ç»“æŸæ—¶æ­£å¥½åœ¨é—ªçƒ)
			if (player) player.visible = true;

			[activeObstacles, activeCoins, activeMagnets, activeJetpacks, activeDecorations].forEach(arr => {
				arr.forEach(o => scene.remove(o)); arr.length = 0;
			});
			activeTracks.forEach(t => scene.remove(t)); activeTracks.length = 0;
			for (let i = 0; i < 3; i++) createTrackSegment(-i * CONFIG.TRACK_LENGTH);
			for (let i = 10; i < 150; i += 25) { spawnBuilding(-i); }

			player.position.set(0, 0, 0); player.rotation.set(0, 0, 0);
			camera.position.set(0, 5, 8); camera.rotation.set(-0.3, 0, 0);

			targetLane = 1; speed = CONFIG.PLAYER_SPEED_BASE;
			score = 0; coins = 0; distance = 0; survivalTime = 0;
			isJumping = false; isSliding = false; verticalVelocity = 0;
			cycleTime = 0;

			magnetActive = false; magnetTimer = 0;
			jetpackActive = false; jetpackTimer = 0;
			isPaused = false;
			world.lastMovingTrainTime = 0;

			document.getElementById('magnet-status').classList.remove('active');
			document.getElementById('jetpack-status').classList.remove('active');

			if (player && player.userData && player.userData.pack) {
				player.userData.pack.visible = false;
			}

			let autoUsed = false;
			if (GameData.settings.autoJetpack && GameData.inventory.jetpack > 0) {
				GameData.inventory.jetpack--; activateJetpack(); autoUsed = true;
			} else if (GameData.settings.autoMagnet && GameData.inventory.magnet > 0) {
				GameData.inventory.magnet--; activateMagnet(); autoUsed = true;
			}
			if (autoUsed) GameData.save();

			world.lastSpawnZ = 0;
			gameActive = true;
			updateHUD();

			document.getElementById('main-menu').classList.add('hidden');
			document.getElementById('game-over').classList.add('hidden');
			document.getElementById('pause-btn').classList.remove('hidden');
			document.getElementById('hud-panel').classList.remove('hidden');
		}
		window.startGame = startGame;

		function updateDayNightCycle(delta) {
			cycleTime += delta;
			const progress = (cycleTime % CONFIG.CYCLE_DURATION) / CONFIG.CYCLE_DURATION;

			let skyColor, sunColor = 0xFFFFDD, lightIntensity = 0.4, emissiveIntensity = 0.2;

			if (progress < 0.2) {
				const t = progress / 0.2;
				skyColor = new THREE.Color(CONFIG.COLORS.skyNight).lerp(new THREE.Color(CONFIG.COLORS.skySunrise), t);
				lightIntensity = 0.3 + t * 0.5; emissiveIntensity = 0.5 * (1 - t);
			} else if (progress < 0.5) {
				const t = (progress - 0.2) / 0.3;
				skyColor = new THREE.Color(CONFIG.COLORS.skySunrise).lerp(new THREE.Color(CONFIG.COLORS.skyDay), t);
				lightIntensity = 0.8 + t * 0.4; emissiveIntensity = 0; sunColor = 0xFFFFAA;
			} else if (progress < 0.7) {
				const t = (progress - 0.5) / 0.2;
				skyColor = new THREE.Color(CONFIG.COLORS.skyDay).lerp(new THREE.Color(CONFIG.COLORS.skySunset), t);
				lightIntensity = 1.2 - t * 0.6; emissiveIntensity = t * 0.3; sunColor = 0xFFCC00;
			} else {
				const t = (progress - 0.7) / 0.3;
				skyColor = new THREE.Color(CONFIG.COLORS.skySunset).lerp(new THREE.Color(CONFIG.COLORS.skyNight), t);
				lightIntensity = 0.6 - t * 0.3; emissiveIntensity = 0.3 + t * 0.2; sunColor = 0xDDDDFF;
			}

			// å°†è®¡ç®—å‡ºçš„ progress ä¼ ç»™äº‘ç³»ç»Ÿï¼Œè®©å®ƒè‡ªå·±å˜è‰²
			CloudSystem.updateColor(progress);

			scene.background = skyColor; scene.fog.color = skyColor;
			ambientLight.intensity = lightIntensity * 0.6; dirLight.intensity = lightIntensity;

			const angle = progress * Math.PI * 2;
			sunMesh.position.x = Math.cos(angle) * 100; sunMesh.position.y = Math.sin(angle) * 100;
			sunMesh.material.color.setHex(sunColor);

			buildingMaterials.forEach(mat => { mat.emissiveIntensity = emissiveIntensity; });
		}

		function animate() {
			requestAnimationFrame(animate);
			const delta = clock.getDelta();

			if (gameActive) {
				if (!isPaused) {
					updateDayNightCycle(delta);

					// 1. äº‘å±‚æ›´æ–°
					CloudSystem.update(delta, player.position.z);

					// 2. ç‰¹æ•ˆæ›´æ–°
					VFX.update(delta);

					// 3. æ— æ•Œé—ªçƒé€»è¾‘
					if (isInvincible) {
						invincibleTimer -= delta;
						const blinkSpeed = 100;
						player.visible = Math.floor(Date.now() / blinkSpeed) % 2 === 0;
						if (invincibleTimer <= 0) {
							isInvincible = false;
							player.visible = true;
						}
					} else {
						if (!player.visible) player.visible = true;
					}

					// 4. ç§»åŠ¨è·ç¦»è®¡ç®—
					const moveDist = speed * delta;
					player.position.z -= moveDist;
					distance += moveDist;

					if (speed < CONFIG.PLAYER_SPEED_MAX) { speed += CONFIG.SPEED_ACCELERATION * delta; }

					const tx = CONFIG.LANES[targetLane];
					player.position.x += (tx - player.position.x) * 10 * delta;

					// 5. éšœç¢ç‰©ç§»åŠ¨ (ç«è½¦)
					activeObstacles.forEach(obs => {
						if (obs.userData.isMovingTrain) {
							obs.position.z += obs.userData.trainSpeed * delta;
						}
					});

					// =========================================
					// æ ¸å¿ƒä¿®å¤ï¼šç›¸æœºä¸åœ°é¢æ£€æµ‹é€»è¾‘
					// =========================================

					// A. å…ˆæ£€æµ‹åœ°é¢ (è¿™ä¼šæ›´æ–°å…¨å±€å˜é‡ currentGroundY)
					checkGroundStatus();

					// B. åŸºäºåœ°é¢è®¡ç®—ç›¸æœºç›®æ ‡ (å…³é”®ç‚¹ï¼šè¿™é‡Œå¿…é¡»åŠ¨æ€è®¡ç®—!)
					// å¦‚æœåœ¨åœ°é¢(0)ï¼ŒtargetY = 5; å¦‚æœåœ¨è½¦é¡¶(4)ï¼ŒtargetY = 9
					let targetY = currentGroundY + 5;
					let targetZOffset = 8;
					let targetRotX = -0.1;

					// C. å–·æ°”èƒŒåŒ…é€»è¾‘ (å¦‚æœæœ‰ï¼Œå¼ºåˆ¶è¦†ç›–ç›¸æœºå‚æ•°)
					if (jetpackActive) {
						jetpackTimer -= delta;
						document.getElementById('jetpack-timer').innerText = jetpackTimer.toFixed(1) + 's';
						if (jetpackTimer <= 0) {
							jetpackActive = false;
							document.getElementById('jetpack-status').classList.remove('active');
						}

						player.userData.pack.visible = true;
						const hoverWave = Math.sin(Date.now() * 0.005) * 0.3;
						const targetH = CONFIG.JETPACK_HEIGHT + hoverWave;
						player.position.y += (targetH - player.position.y) * 5 * delta;

						// å¼ºåˆ¶è¦†ç›–ç›¸æœºé«˜åº¦
						targetY = 12;
						targetZOffset = 14;
						targetRotX = -0.45;

						player.rotation.x = 0.2; player.rotation.z = -(tx - player.position.x) * 0.15;
						player.userData.flames.forEach(f => {
							f.visible = true; const pulse = 1.5 + Math.sin(Date.now() * 0.02) * 0.5;
							f.scale.set(pulse, pulse * 1.2, pulse);
						});
						player.userData.lLeg.position.z = -0.1; player.userData.rLeg.position.z = -0.1;
						player.userData.lLeg.rotation.x = -0.2 + hoverWave * 0.2; player.userData.rLeg.rotation.x = -0.2 + hoverWave * 0.2;
						player.userData.lArm.rotation.x = -0.5; player.userData.rArm.rotation.x = -0.5;
						isJumping = false; isSliding = false;

					} else {
						// æ™®é€šçŠ¶æ€é€»è¾‘
						player.userData.pack.visible = false;
						player.rotation.x = 0; player.rotation.z = -(tx - player.position.x) * 0.15;

						if (isJumping) {
							player.position.y += verticalVelocity;
							verticalVelocity -= CONFIG.GRAVITY;

							// è½åœ°åˆ¤å®šï¼šä½¿ç”¨ currentGroundY
							if (player.position.y <= currentGroundY) {
								player.position.y = currentGroundY;
								isJumping = false;
								verticalVelocity = 0;
							}
						} else {
							// è·‘åŠ¨ä¸­ï¼šå¤„ç†ä¸‹è½
							if (player.position.y > currentGroundY) {
								player.position.y -= CONFIG.GRAVITY * 15;
								if (player.position.y < currentGroundY) player.position.y = currentGroundY;
							} else if (player.position.y < currentGroundY) {
								player.position.y = currentGroundY;
							}
						}

						if (isSliding) {
							slideTimer -= delta; player.scale.y = 0.5;
							if (slideTimer <= 0) { isSliding = false; player.scale.y = 1; }
						}

						if (!isJumping && !isSliding) {
							const time = Date.now() * 0.015;
							player.userData.lLeg.rotation.x = 0; player.userData.rLeg.rotation.x = 0;
							player.userData.lLeg.position.z = Math.sin(time) * 0.2; player.userData.rLeg.position.z = Math.cos(time) * 0.2;
							player.userData.lArm.rotation.x = Math.cos(time) * 0.5; player.userData.rArm.rotation.x = Math.sin(time) * 0.5;
						}
					}

					// 6. ç£é“ä¸é‡‘å¸é€»è¾‘ (ä½ çš„ç‰ˆæœ¬é‡Œæœ‰ï¼Œä¿æŒä¸å˜)
					if (magnetActive) {
						magnetTimer -= delta;
						document.getElementById('magnet-timer').innerText = magnetTimer.toFixed(1) + 's';
						if (magnetTimer <= 0) {
							magnetActive = false;
							document.getElementById('magnet-status').classList.remove('active');
						}
						activeCoins.forEach(coin => {
							if (coin.position.distanceTo(player.position) < CONFIG.MAGNET_RANGE && !coin.userData.collected) {
								coin.userData.attracted = true;
							}
							if (coin.userData.attracted) {
								const target = player.position.clone().add(new THREE.Vector3(0, 1, 0));
								const flySpeed = Math.max(50, speed * 2.5);
								const direction = target.clone().sub(coin.position).normalize();
								const moveStep = flySpeed * delta;
								coin.position.add(direction.multiplyScalar(moveStep));
								const dist = coin.position.distanceTo(target);
								if (dist < 1.5 || dist < moveStep) collectCoin(coin);
							}
						});
					}

					updateWorldGen();
					checkTrainInteractions();
					checkCollisions();

					score = Math.floor(distance * 10) + (coins * 50);
					survivalTime += delta;
					updateHUD();

					// =========================================
					// D. åº”ç”¨ç›¸æœºä½ç½® (æ­¤æ—¶ targetY ç»å¯¹æ˜¯æ­£ç¡®çš„)
					// =========================================
					camera.position.y += (targetY - camera.position.y) * 3 * delta;
					const desiredZ = player.position.z + targetZOffset;
					camera.position.z += (desiredZ - camera.position.z) * 5 * delta;
					camera.position.x = player.position.x * 0.4;
					camera.rotation.x += (targetRotX - camera.rotation.x) * 3 * delta;
				}
			} else {
				// æ¸¸æˆç»“æŸæ—¶çš„ç©ºè½¬é•œå¤´
				const t = Date.now() * 0.002;
				player.position.y = Math.sin(t) * 0.1;
				player.rotation.y += 0.01;
			}
			renderer.render(scene, camera);
		}

		function checkGroundStatus() {
			// é»˜è®¤åœ°é¢æ˜¯ 0
			let newGroundY = 0;
			onTrain = false; // é‡ç½®çŠ¶æ€

			// è·å–ç©å®¶å½“å‰çš„ä¸­å¿ƒç‚¹
			const pBox = new THREE.Box3().setFromObject(player);
			const center = new THREE.Vector3();
			pBox.getCenter(center);

			// åªæ£€æµ‹è„šä¸‹çš„æ ¸å¿ƒåŒºåŸŸ
			const footCheckX = center.x;
			const footCheckZ = center.z;

			// éå†æ‰€æœ‰éšœç¢ç‰©
			for (let obs of activeObstacles) {
				// === ä¿®å¤çš„æ ¸å¿ƒç‚¹ START ===
				// åˆ¤å®šæ˜¯å¦ä¸ºç«è½¦ï¼š
				// 1. å®ƒæ˜¯ç§»åŠ¨ç«è½¦ (isMovingTrain)
				// 2. æˆ–è€…å®ƒæ˜¯éšœç¢ç‰©ä¸”è™½ç„¶Yæ˜¯0ä½†åŒ…å›´ç›’å¾ˆé«˜ (BoxMaxY > 2)
				// ä¸ºäº†ç®€å•ç¨³å®šï¼Œæˆ‘ä»¬ç›´æ¥æ£€æŸ¥ userData é‡Œçš„æ ‡è®°
				const isTrain = obs.userData.isMovingTrain === true || (obs.userData.isObstacle === true && !obs.userData.isHigh);
				// === ä¿®å¤çš„æ ¸å¿ƒç‚¹ END ===

				if (isTrain) {
					const obsBox = new THREE.Box3().setFromObject(obs);

					// æ‰©å±•ä¸€ä¸‹åˆ¤å®šèŒƒå›´ï¼Œè®©ä¸Šè½¦ç¨å¾®å®¹æ˜“ä¸€ç‚¹ç‚¹
					obsBox.expandByScalar(0.2);

					// æ ¸å¿ƒåˆ¤å®šï¼šç©å®¶åœ¨ç«è½¦çš„ X/Z å¹³é¢èŒƒå›´å†…
					if (footCheckX >= obsBox.min.x && footCheckX <= obsBox.max.x &&
						footCheckZ >= obsBox.min.z && footCheckZ <= obsBox.max.z) {

						// ç«è½¦é¡¶éƒ¨é«˜åº¦å›ºå®šä¸º 4.0
						const trainTopY = 4.0;

						// å¦‚æœæˆ‘ä»¬å·²ç»åœ¨è½¦é¡¶é™„è¿‘ (åŠ ä¸€ç‚¹å®¹å·®ï¼Œé˜²æ­¢æ‰ä¸‹å»)
						// åªè¦è„šåº•æ¿é«˜åº¦ > 3.0 å°±è®¤ä¸ºåœ¨è½¦é¡¶èŒƒå›´
						if (player.position.y >= 3.0) {
							newGroundY = trainTopY;
							onTrain = true;
							break; // æ‰¾åˆ°äº†æ”¯æ’‘ç‚¹
						}
					}
				}
			}

			// æ›´æ–°å…¨å±€å˜é‡
			currentGroundY = newGroundY;
		}

		function checkCollisions() {
			// è·å–ç©å®¶åŒ…å›´ç›’
			const pBox = new THREE.Box3().setFromObject(player);
			// ç¨å¾®ç¼©å°ä¸€ç‚¹ç©å®¶çš„åˆ¤å®šèŒƒå›´ï¼Œé¿å…è¹­åˆ°ç©ºæ°”å¢™
			pBox.min.x += 0.3; pBox.max.x -= 0.3;
			pBox.min.z += 0.2; pBox.max.z -= 0.2;

			const playerBottomY = player.position.y;

			// --- 1. éšœç¢ç‰©æ£€æµ‹ ---
			if (!jetpackActive) {
				for (let i = activeObstacles.length - 1; i >= 0; i--) {
					const obs = activeObstacles[i];

					// è·å–éšœç¢ç‰©åŒ…å›´ç›’
					const obsBox = new THREE.Box3().setFromObject(obs);

					// ç¢°æ’å‘ç”Ÿï¼
					if (pBox.intersectsBox(obsBox)) {

						// æ»‘é“²ç©¿è¿‡é«˜æ¶è·¯éšœ
						if (isSliding && obs.userData.isHigh) continue;

						const isHeavy = obs.userData.isObstacle === true;

						if (isHeavy) {
							// === ä¿®å¤çš„æ ¸å¿ƒé€»è¾‘ START ===

							// ç«è½¦é¡¶éƒ¨é«˜åº¦ (Body Y=2.25, Height=3.5 -> Top=4.0)
							// æˆ‘ä»¬ç»™ 4.0 ä¸€ä¸ªç¨å¾®å®½æ¾çš„åˆ¤å®šçº¿
							const trainTopY = 4.0;

							// åˆ¤å®šè±å…æ¡ä»¶ï¼š
							// 1. å¿…é¡»æ˜¯ä¸‹è½çŠ¶æ€ (verticalVelocity <= 0) æˆ–è€…æ˜¯è·‘åŠ¨çŠ¶æ€ (0)
							// 2. ç©å®¶è„šåº•é«˜åº¦ > ç«è½¦ä¸­å¿ƒé«˜åº¦ (2.25)ã€‚
							//    æ³¨æ„ï¼šè¿™é‡Œä¸è¦ç”¨ trainTopY(4.0) å»æ¯”ï¼Œå› ä¸ºä½ å¯èƒ½å·²ç»é™·è¿›å»äº†ä¸€ç‚¹ç‚¹ã€‚
							//    åªè¦ä½ åœ¨ç«è½¦â€œè…°éƒ¨â€ä»¥ä¸Šï¼Œä¸”æ­£åœ¨å¾€ä¸‹è½ï¼Œæˆ‘ä»¬å°±è®¤ä¸ºä½ æ˜¯æƒ³è¸©ä¸Šå»ã€‚
							const toleranceThreshold = 2.5;

							if (verticalVelocity <= 0 && playerBottomY > toleranceThreshold) {
								// ã€åˆ¤å®šä¸ºç€é™†ï¼ã€‘

								// 1. å¼ºåˆ¶ä¿®æ­£ä½ç½®ï¼šæŠŠç©å®¶ä»ç«è½¦èº«ä½“é‡Œâ€œæâ€å‡ºæ¥ï¼Œæ”¾åˆ°è½¦é¡¶
								player.position.y = trainTopY;

								// 2. ç‰©ç†çŠ¶æ€é‡ç½®
								verticalVelocity = 0;
								isJumping = false;
								onTrain = true;

								// 3. æ›´æ–°å…¨å±€åœ°é¢é«˜åº¦ï¼Œé˜²æ­¢ä¸‹ä¸€å¸§æ‰ä¸‹å»
								currentGroundY = trainTopY;

								// 4. è·³è¿‡æ­»äº¡åˆ¤å®š
								continue;
							}
							// === ä¿®å¤çš„æ ¸å¿ƒé€»è¾‘ END ===

							// å¦‚æœä¸æ»¡è¶³ä¸Šè¿°æ¡ä»¶ï¼Œé‚£å°±æ˜¯æ’åˆ°äº†ä¾§é¢æˆ–åº•éƒ¨ -> æ­»äº¡
							gameOver();
							return;
						} else {
							// æ’å°éšœç¢ (é€»è¾‘ä¸å˜)
							if (isInvincible) {
								smashObstacle(obs, i);
							} else if (hasShield) {
								activateInvincibility();
								smashObstacle(obs, i);
							} else {
								gameOver();
								return;
							}
						}
					}
				}
			}

			// --- 2. é“å…·æ‹¾å– (ä¿æŒä¸å˜) ---
			const checkItem = (list, action) => {
				for (let i = list.length - 1; i >= 0; i--) {
					const item = list[i]; item.rotation.y += 0.05;
					const iBox = new THREE.Box3().setFromObject(item); iBox.expandByScalar(0.5);
					if (pBox.intersectsBox(iBox)) { action(); scene.remove(item); list.splice(i, 1); }
				}
			};
			checkItem(activeMagnets, activateMagnet);
			checkItem(activeJetpacks, activateJetpack);

			// --- 3. é‡‘å¸æ‹¾å– (ä¿æŒä¸å˜) ---
			for (let i = activeCoins.length - 1; i >= 0; i--) {
				const coin = activeCoins[i];
				if (coin.userData.collected) continue;

				if (coin.userData.type === 'star') {
					coin.rotation.y += 0.02; coin.userData.ring.rotation.x += 0.05; coin.userData.ring.rotation.y += 0.05;
				} else {
					coin.rotation.y += coin.userData.rotateSpeed || 0.1;
				}

				const coinBox = new THREE.Box3().setFromObject(coin);
				if (coin.userData.type !== 'normal') coinBox.expandByScalar(0.2);

				if (pBox.intersectsBox(coinBox)) collectCoin(coin);
			}
		}

		// è¾…åŠ©å‡½æ•°ï¼šè§¦å‘æ— æ•Œ
		function activateInvincibility() {
			hasShield = false; // æ¶ˆè€—æŠ¤ç›¾
			isInvincible = true;
			invincibleTimer = CONFIG.INVINCIBLE_DURATION;

			// æ’­æ”¾æŠ¤ç›¾ç ´ç¢éŸ³æ•ˆ (å€Ÿç”¨ä¸€ä¸‹æ’å‡»éŸ³æ•ˆï¼Œæˆ–è€…ä½ å¯ä»¥åŠ ä¸ªæ›´ç”µå­çš„å£°éŸ³)
			AudioSys.playTone(800, 'sawtooth', 0.1, 0.2);
			setTimeout(() => AudioSys.playTone(400, 'sawtooth', 0.3, 0.2), 100);

			// è§†è§‰æç¤ºï¼šä¹Ÿå¯ä»¥åœ¨è¿™é‡ŒåŠ ä¸ªè“è‰²çš„çˆ†ç‚¸åœˆ
			VFX.explode(player.position, 0x00FFFF, 1.5);
		}

		// è¾…åŠ©å‡½æ•°ï¼šæ’ç¢éšœç¢ç‰©
		function smashObstacle(obs, index) {
			// ç§»é™¤éšœç¢ç‰©
			scene.remove(obs);
			activeObstacles.splice(index, 1);

			// æ’­æ”¾ç‰¹æ•ˆ
			VFX.explode(obs.position, 0xE67E22, 1.0); // æ©™è‰²ç¢ç‰‡
			AudioSys.playSmash(false); // è½»æ’å‡»å£°
		}

		// æˆ‘ä»¬éœ€è¦åœ¨æ¯ä¸€å¸§æ£€æµ‹è¡Œé©¶ä¸­çš„ç«è½¦å‰æ–¹æ˜¯å¦æœ‰ä¸œè¥¿
		function checkTrainInteractions() {
			// ç­›é€‰å‡ºæ‰€æœ‰æ­£åœ¨è¡Œé©¶çš„ç«è½¦
			const movingTrains = activeObstacles.filter(o => o.userData.isMovingTrain && !o.userData.dead);

			movingTrains.forEach(train => {
				// åˆ›å»ºä¸€ä¸ªç¨å¾®æ¯”ç«è½¦å¤§ä¸€ç‚¹çš„åŒ…å›´ç›’ï¼Œç”¨äºæ£€æµ‹
				const trainBox = new THREE.Box3().setFromObject(train);
				// æ”¶ç¼©ä¸€ç‚¹ Z è½´ï¼Œé¿å…åˆšåˆšç”Ÿæˆæ—¶è¯¯åˆ¤ï¼Œåªæ£€æµ‹è½¦å¤´æ’å‡»
				trainBox.min.z += 1.0;
				trainBox.max.z -= 1.0;

				// éå†æ‰€æœ‰å…¶ä»–éšœç¢ç‰©
				for (let i = activeObstacles.length - 1; i >= 0; i--) {
					const target = activeObstacles[i];

					// è·³è¿‡è‡ªå·±ã€è·³è¿‡å·²ç»æ ‡è®°æ­»äº¡çš„ç‰©ä½“
					if (train === target || target.userData.dead) continue;

					const targetBox = new THREE.Box3().setFromObject(target);

					// å¦‚æœæ’ä¸Šäº†
					if (trainBox.intersectsBox(targetBox)) {

						// æƒ…å†µ 1: æ’åˆ°äº†é™æ­¢ç«è½¦ (æˆ–è€…å¦ä¸€è¾†ç§»åŠ¨ç«è½¦)
						if (target.userData.isObstacle && !target.userData.isHigh) { // isHighé€šå¸¸æ˜¯è·¯éšœæ¶å­ï¼Œè¿™é‡Œç²—ç•¥åˆ¤æ–­ä½“ç§¯å¤§çš„éšœç¢ç‰©

							// é€»è¾‘ï¼šè¡Œé©¶çš„ç«è½¦â€œå‘ç”Ÿäº‹æ•…â€æ¶ˆå¤±
							train.userData.dead = true;
							scene.remove(train); // ç§»é™¤è¡Œé©¶ç«è½¦

							// ç‰¹æ•ˆï¼šå¤§çˆ†ç‚¸ï¼Œé»‘è‰²ç¢ç‰‡ (æ¨¡æ‹Ÿé›¶ä»¶)
							VFX.explode(train.position, 0x111111, 2.0);
							AudioSys.playSmash(true); // é‡éŸ³æ•ˆ

							// æ—¢ç„¶ç«è½¦éƒ½æ²¡äº†ï¼Œå°±ä¸éœ€è¦æ£€æµ‹å®ƒæ’åˆ«çš„äº†ï¼Œç›´æ¥é€€å‡ºå½“å‰å¾ªç¯
							break;
						}

						// æƒ…å†µ 2: æ’åˆ°äº†å°éšœç¢ç‰© (æ æ†ã€è·¯éšœ)
						// æˆ–è€…æ˜¯é«˜æ¶è·¯éšœçš„æŸ±å­
						else {
							// é€»è¾‘ï¼šéšœç¢ç‰©è¢«ç¢¾ç¢
							target.userData.dead = true;
							scene.remove(target); // ç§»é™¤éšœç¢ç‰©
							activeObstacles.splice(i, 1); // ä»æ•°ç»„ä¸­ç§»é™¤

							// ç‰¹æ•ˆï¼šå°çˆ†ç‚¸ï¼Œç¢ç‰‡é¢œè‰²å–è‡ªéšœç¢ç‰©æœ¬èº«é¢œè‰² (æˆ–è€…æ˜¯é€šç”¨çš„æ©™è‰²/ç°è‰²)
							// ç®€å•çš„åšæ³•æ˜¯ç»™ä¸ªæ©™è‰²
							VFX.explode(target.position, 0xE67E22, 1.0);
							AudioSys.playSmash(false); // è½»éŸ³æ•ˆ
						}
					}
				}
			});

			// æ¸…ç†å·²æ ‡è®°æ­»äº¡çš„è¡Œé©¶ç«è½¦
			for (let i = activeObstacles.length - 1; i >= 0; i--) {
				if (activeObstacles[i].userData.dead) {
					activeObstacles.splice(i, 1);
				}
			}
		}

		function activateMagnet() {
			magnetActive = true; magnetTimer = CONFIG.MAGNET_DURATION;
			document.getElementById('magnet-status').classList.add('active');
			AudioSys.playPowerup();
		}
		function activateJetpack() {
			jetpackActive = true; jetpackTimer = CONFIG.JETPACK_DURATION;
			document.getElementById('jetpack-status').classList.add('active');
			AudioSys.playPowerup();
		}

		function collectCoin(coin) {
			if (coin.userData.collected) return;
			coin.userData.collected = true;

			// è·å–é‡‘å¸ä»·å€¼
			let value = coin.userData.value || 1;

			// å¦‚æœæ˜¯æ™®é€šé‡‘å¸ï¼Œåº”ç”¨é€Ÿåº¦å€ç‡å¥–åŠ±ï¼›å¦‚æœæ˜¯ç‰¹æ®Šé‡‘å¸ï¼Œç›´æ¥ç»™å›ºå®šé«˜é¢å¥–åŠ±
			if (coin.userData.type === 'normal') {
				const multiplier = 1 + Math.floor((speed - CONFIG.PLAYER_SPEED_BASE) / 5);
				value = value * multiplier;
				AudioSys.playCoin(); // æ™®é€šéŸ³æ•ˆ
			} else {
				// ç‰¹æ®Šé‡‘å¸éŸ³æ•ˆï¼šé¢‘ç‡æ›´é«˜ï¼ŒæŒç»­æ—¶é—´æ›´é•¿
				AudioSys.playTone(2000, 'square', 0.2, 0.2);
				setTimeout(() => AudioSys.playTone(3000, 'sine', 0.4, 0.2), 100);
			}

			coins += value;

			// å¯é€‰ï¼šåœ¨è¿™é‡Œæ·»åŠ ä¸€ä¸ªæµ®åŠ¨æ–‡å­—ç‰¹æ•ˆ "+50" (éœ€è¦é¢å¤–çš„DOMæ“ä½œï¼Œæš‚æ—¶ç•¥è¿‡ï¼ŒUIä¼šè‡ªåŠ¨è·³æ•°å­—)

			scene.remove(coin);
			activeCoins.splice(activeCoins.indexOf(coin), 1);
		}

		function updateWorldGen() {
			if (activeTracks[0].position.z > player.position.z + CONFIG.TRACK_LENGTH) {
				const seg = activeTracks.shift(); seg.position.z = activeTracks[activeTracks.length - 1].position.z - CONFIG.TRACK_LENGTH; activeTracks.push(seg);
			}
			if (world.lastSpawnZ > player.position.z - 80) { world.lastSpawnZ -= 25; spawnObstacle(world.lastSpawnZ); }
			const clean = (arr) => { for (let i = arr.length - 1; i >= 0; i--) { if (arr[i].position.z > player.position.z + 20) { scene.remove(arr[i]); arr.splice(i, 1); } } };
			clean(activeObstacles); clean(activeCoins); clean(activeMagnets); clean(activeJetpacks); clean(activeDecorations);
		}

		// --- V23: CHARACTER SYSTEM LOGIC ---
		const CharSys = {
			show: function (e) {
				if (e && e.stopPropagation) e.stopPropagation();
				this.render();
				// Hide Main Menu to prevent bugs
				document.getElementById('main-menu').classList.add('hidden');
				document.getElementById('char-screen').classList.remove('hidden');
			},
			close: function (e) {
				if (e && e.stopPropagation) e.stopPropagation();
				document.getElementById('char-screen').classList.add('hidden');
				document.getElementById('main-menu').classList.remove('hidden');
			},
			render: function () {
				const grid = document.getElementById('char-grid');
				grid.innerHTML = '';
				document.getElementById('char-coin-count').innerText = GameData.coins;
				document.getElementById('char-title').innerText = LANG[currentLang].charTitle;
				document.getElementById('char-close-btn').innerText = LANG[currentLang].charBack;

				for (const [id, data] of Object.entries(CHARACTERS)) {
					const isOwned = GameData.unlockedChars.includes(id);
					const isEquipped = GameData.curChar === id;

					let btnClass = isEquipped ? "buy-btn equipped" : (isOwned ? "buy-btn select" : "buy-btn");
					let btnText = isEquipped ? LANG[currentLang].equipped : (isOwned ? LANG[currentLang].equip : `${LANG[currentLang].buy} ${data.cost}`);
					// Use window.CharSys to ensure global access in onclick string
					let clickAction = isOwned ? `CharSys.equip('${id}')` : `CharSys.buy('${id}')`;

					grid.innerHTML += `
                <div class="store-item">
                    <div class="item-icon" style="color:#${new THREE.Color(data.color).getHexString()}">ğŸ¤–</div>
                    <div class="item-name">${data.name}</div>
                    <div class="item-desc">${isOwned ? LANG[currentLang].owned : ''}</div>
                    <button class="${btnClass}" onclick="${clickAction}">
                        ${!isOwned ? '<div class="css-coin" style="width:15px; height:15px;"></div>' : ''} ${btnText}
                    </button>
                </div>
            `;
				}
			},
			buy: function (id) {
				const char = CHARACTERS[id];
				if (GameData.coins >= char.cost) {
					GameData.coins -= char.cost;
					GameData.unlockedChars.push(id);
					GameData.curChar = id;
					GameData.save();
					AudioSys.playCoin();
					this.render();
					// Update player model in background immediately
					createPlayerModel();
				}
			},
			equip: function (id) {
				GameData.curChar = id;
				GameData.save();
				this.render();
				createPlayerModel();
			}
		};
		window.CharSys = CharSys;

		// --- GLOBAL BINDINGS ---
		const Store = {
			updateUI: function () {
				document.getElementById('store-coin-count').innerText = GameData.coins;
				document.getElementById('item-own-mag').innerText = LANG[currentLang].itemOwn + GameData.inventory.magnet;
				document.getElementById('buy-mag-btn').disabled = GameData.coins < CONFIG.COST_MAGNET;
				document.getElementById('check-mag').checked = GameData.settings.autoMagnet;
				document.getElementById('item-own-jet').innerText = LANG[currentLang].itemOwn + GameData.inventory.jetpack;
				document.getElementById('buy-jet-btn').disabled = GameData.coins < CONFIG.COST_JETPACK;
				document.getElementById('check-jet').checked = GameData.settings.autoJetpack;
			},
			buy: function (item) {
				if (item === 'magnet' && GameData.coins >= CONFIG.COST_MAGNET) {
					GameData.coins -= CONFIG.COST_MAGNET; GameData.inventory.magnet++;
					AudioSys.playCoin();
				}
				else if (item === 'jetpack' && GameData.coins >= CONFIG.COST_JETPACK) {
					GameData.coins -= CONFIG.COST_JETPACK; GameData.inventory.jetpack++;
					AudioSys.playCoin();
				}
				GameData.save(); this.updateUI(); updateHUD();
			},
			toggle: function (item) {
				if (item === 'magnet') GameData.settings.autoMagnet = document.getElementById('check-mag').checked;
				if (item === 'jetpack') GameData.settings.autoJetpack = document.getElementById('check-jet').checked;
				GameData.save();
			},
			show: function (e) {
				if (e && e.stopPropagation) e.stopPropagation();
				this.updateUI();
				document.getElementById('store-screen').classList.remove('hidden');
				document.getElementById('main-menu').classList.add('hidden');
			}
		};
		window.Store = Store;

		function closeStore(e) {
			if (e && e.stopPropagation) e.stopPropagation();
			document.getElementById('store-screen').classList.add('hidden');
			document.getElementById('main-menu').classList.remove('hidden');
		}
		window.closeStore = closeStore;

		function togglePause(e) {
			if (e && e.stopPropagation) e.stopPropagation();
			if (!gameActive) return;
			isPaused = !isPaused;

			if (isPaused) {
				document.getElementById('pause-screen').classList.remove('hidden');
				document.getElementById('pause-btn').classList.add('hidden');
				AudioSys.stopBGM();
			} else {
				document.getElementById('pause-screen').classList.add('hidden');
				document.getElementById('pause-btn').classList.remove('hidden');
				clock.getDelta();
				AudioSys.startBGM();
			}
		}
		window.togglePause = togglePause;

		function goHome(e) {
			if (e && e.stopPropagation) e.stopPropagation();
			gameActive = false;
			isPaused = false;
			AudioSys.stopBGM();

			document.getElementById('game-over').classList.add('hidden');
			document.getElementById('pause-screen').classList.add('hidden');
			document.getElementById('pause-btn').classList.add('hidden');
			document.getElementById('hud-panel').classList.add('hidden');
			document.getElementById('main-menu').classList.remove('hidden');

			if (document.getElementById('menu-coin-count')) document.getElementById('menu-coin-count').innerText = GameData.coins;

			// Reset Camera
			camera.position.set(0, 4, 10);
			camera.rotation.set(-0.1, 0, 0);

			if (player) {
				player.position.set(0, 0, 0); player.rotation.set(0, 0, 0);
				if (player.userData.pack) player.userData.pack.visible = false;
				if (player.userData.flames) player.userData.flames.forEach(f => f.visible = false);
			}
			try {
				const cleanup = (arr) => { if (arr) { arr.forEach(o => scene.remove(o)); arr.length = 0; } };
				cleanup(activeObstacles); cleanup(activeCoins); cleanup(activeMagnets); cleanup(activeJetpacks); cleanup(activeDecorations);
				if (activeTracks) { activeTracks.forEach(t => scene.remove(t)); activeTracks.length = 0; for (let i = 0; i < 3; i++) createTrackSegment(-i * CONFIG.TRACK_LENGTH); }
				world.lastSpawnZ = 0;
			} catch (e) { console.warn("Cleanup warning:", e); }
		}
		window.goHome = goHome;

		const Leaderboard = {
			data: [], sortField: 'score', sortDesc: true, load: function () { this.data = JSON.parse(localStorage.getItem('moonChaser_ranks') || '[]') }, save: function (n, s, t) { this.load(); this.data.push({ name: n || "Guest", score: s, time: t }); localStorage.setItem('moonChaser_ranks', JSON.stringify(this.data)) },
			show: function (e) {
				if (e && e.stopPropagation) e.stopPropagation();
				this.load(); this.render(); document.getElementById('leaderboard-screen').classList.remove('hidden');
				document.getElementById('main-menu').classList.add('hidden');
			}, sort: function (f) { if (this.sortField === f) this.sortDesc = !this.sortDesc; else { this.sortField = f; this.sortDesc = true } this.render() }, render: function () { const b = document.getElementById('lb-body'); b.innerHTML = '';['name', 'score', 'time'].forEach(f => document.getElementById(`sort-${f}`).innerText = (this.sortField === f ? (this.sortDesc ? 'â–¼' : 'â–²') : '')); this.data.sort((a, c) => { let va = a[this.sortField], vb = c[this.sortField]; if (typeof va === 'string') { va = va.toLowerCase(); vb = vb.toLowerCase() } return (va < vb ? (this.sortDesc ? 1 : -1) : (va > vb ? (this.sortDesc ? -1 : 1) : 0)) }); const l = Math.min(10, this.data.length); if (l === 0) b.innerHTML = `<tr><td colspan="4" style="padding:20px;color:#999;">${LANG[currentLang].lbNoRecord}</td></tr>`; for (let i = 0; i < l; i++) { const d = this.data[i], m = Math.floor(d.time / 60).toString().padStart(2, '0'), s = Math.floor(d.time % 60).toString().padStart(2, '0'); const c = i === 0 ? '#FFD700' : (i === 1 ? '#C0C0C0' : (i === 2 ? '#CD7F32' : 'white')); b.innerHTML += `<tr><td style="color:${c}">#${i + 1}</td><td style="color:${c}">${d.name}</td><td>${d.score}</td><td>${m}:${s}</td></tr>` } }
		};
		window.Leaderboard = Leaderboard;

		document.getElementById('lb-close-btn').onclick = (e) => {
			if (e && e.stopPropagation) e.stopPropagation();
			document.getElementById('leaderboard-screen').classList.add('hidden');
			document.getElementById('main-menu').classList.remove('hidden');
		};

		function updateHUD() {
			// 1. æ›´æ–°åˆ†æ•°å’Œé‡‘å¸ (åŸæœ‰é€»è¾‘)
			document.getElementById('score-display').innerText = score.toString().padStart(6, '0');
			document.getElementById('coin-display').innerText = coins;

			const multiplier = 1 + Math.floor((speed - CONFIG.PLAYER_SPEED_BASE) / 5);
			const multElem = document.getElementById('coin-multiplier');
			if (multElem) {
				multElem.innerText = "x" + multiplier;
				multElem.style.color = multiplier > 5 ? '#FF0000' : (multiplier > 2 ? '#FFFF00' : '#00FFFF');
			}

			const speedVal = (speed / CONFIG.PLAYER_SPEED_BASE).toFixed(1);
			document.getElementById('speed-indicator').innerText = "SPEED: " + speedVal + "x";
			if (document.getElementById('menu-coin-count')) document.getElementById('menu-coin-count').innerText = GameData.coins;

			// --- 2. æ–°å¢ï¼šæŠ¤ç›¾ UI é€»è¾‘ ---
			const shieldBar = document.getElementById('shield-status');
			const shieldText = document.getElementById('shield-text');
			const scoreEl = document.getElementById('score-display'); // ç”¨äºæ§åˆ¶åˆ†æ•°é¢œè‰²åé¦ˆ

			if (isInvincible) {
				// çŠ¶æ€ï¼šæ— æ•Œå€’è®¡æ—¶ä¸­
				shieldBar.classList.add('active'); // ç¡®ä¿æ˜¾ç¤º
				shieldBar.classList.add('shield-flicker'); // UIæœ¬èº«ä¹Ÿè·Ÿç€é—ªçƒï¼Œå¢åŠ ç´§å¼ æ„Ÿ
				shieldText.innerText = invincibleTimer.toFixed(1) + "s";

				// åˆ†æ•°é¢œè‰²å˜çº¢/è“é—ªçƒ (å¯é€‰)
				scoreEl.style.color = '#00FFFF';
				scoreEl.style.textShadow = '0 0 15px #00FFFF';

			} else if (hasShield) {
				// çŠ¶æ€ï¼šæŠ¤ç›¾å°±ç»ª
				shieldBar.classList.add('active');
				shieldBar.classList.remove('shield-flicker'); // åœæ­¢é—ªçƒ
				shieldText.innerText = "READY"; // æˆ–è€… "ACTIVE"

				// åˆ†æ•°é¢œè‰²ï¼šé’è‰²å¸¸äº®
				scoreEl.style.color = '#1abc9c';
				scoreEl.style.textShadow = '0 0 5px #1abc9c';

			} else {
				// çŠ¶æ€ï¼šæ— æŠ¤ç›¾
				shieldBar.classList.remove('active');
				shieldBar.classList.remove('shield-flicker');

				// åˆ†æ•°é¢œè‰²ï¼šæ¢å¤ç™½è‰²
				scoreEl.style.color = 'white';
				scoreEl.style.textShadow = '3px 3px 0 #000';
			}
		}

		function gameOver() {
			gameActive = false;
			AudioSys.stopBGM();
			AudioSys.playCrash();

			document.getElementById('hud-panel').classList.add('hidden');
			document.getElementById('pause-btn').classList.add('hidden');
			document.getElementById('game-over').classList.remove('hidden');
			document.getElementById('final-score-val').innerText = score;
			camera.lookAt(player.position);
			GameData.addCoins(coins);
		}

		function updateLocalization() {
			const t = LANG[currentLang];
			document.querySelector('#main-menu .game-title').innerHTML = t.title;
			document.getElementById('play-btn').innerText = t.play;
			document.getElementById('rank-btn').innerText = t.rankBtn;
			document.getElementById('controls-hint').innerHTML = t.controls;
			document.querySelector('#game-over .game-title').innerText = t.crashed;
			document.querySelector('#final-score-box div:first-child').innerText = t.score;
			document.getElementById('restart-btn').innerText = t.lbSave;
			document.getElementById('home-btn').innerText = t.mainMenu;
			document.getElementById('name-input').placeholder = t.lbPlaceholder;
			document.getElementById('lb-title-text').innerText = t.lbTitle;
			document.getElementById('th-rank').innerText = t.lbRank;
			document.getElementById('th-name').firstChild.textContent = t.lbName + " ";
			document.getElementById('th-score').firstChild.textContent = t.lbScore + " ";
			document.getElementById('th-time').firstChild.textContent = t.lbTime + " ";
			document.getElementById('lb-close-btn').innerText = t.lbClose;
			document.getElementById('store-btn').innerText = t.storeBtn;
			document.querySelector('.store-header .game-title').innerText = t.storeTitle;
			document.getElementById('store-close-btn').innerText = t.storeBack;
			document.getElementById('item-name-mag').innerText = t.itemNameMag;
			document.getElementById('item-desc-mag').innerText = t.itemDescMag;
			document.getElementById('auto-use-mag').innerText = t.autoUse;
			document.getElementById('item-name-jet').innerText = t.itemNameJet;
			document.getElementById('item-desc-jet').innerText = t.itemDescJet;
			document.getElementById('auto-use-jet').innerText = t.autoUse;
			document.getElementById('pause-title').innerText = t.pauseTitle;
			document.getElementById('resume-btn').innerText = t.resume;
			document.getElementById('pause-home-btn').innerText = t.pauseMenu;

			// V23: Char Screen Loc
			document.getElementById('char-btn').innerText = t.charTitle;
			if (!document.getElementById('leaderboard-screen').classList.contains('hidden')) Leaderboard.render();
			if (!document.getElementById('store-screen').classList.contains('hidden')) Store.updateUI();
			if (!document.getElementById('char-screen').classList.contains('hidden')) CharSys.render();
		}

		function setupInputs() {
			document.addEventListener('keydown', e => {
				if (isPaused) return;
				if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(e.key)) e.preventDefault();
				if (!gameActive) return;
				if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') { if (targetLane > 0) targetLane--; }
				if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') { if (targetLane < 2) targetLane++; }
				if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W' || e.key === ' ') { if (!isJumping && !jetpackActive) { isJumping = true; verticalVelocity = CONFIG.JUMP_FORCE; isSliding = false; player.scale.y = 1; } }
				if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') { if (!isJumping && !jetpackActive) { isSliding = true; slideTimer = 0.8; verticalVelocity = -0.5; } }
				if (e.key === 'Escape') togglePause();
			});

			let tx = 0, ty = 0;
			document.addEventListener('touchstart', e => { tx = e.changedTouches[0].screenX; ty = e.changedTouches[0].screenY; }, { passive: false });
			document.addEventListener('touchmove', e => { if (gameActive) e.preventDefault(); }, { passive: false });
			document.addEventListener('touchend', e => {
				if (!gameActive || isPaused) return;
				const dx = e.changedTouches[0].screenX - tx, dy = e.changedTouches[0].screenY - ty;
				if (Math.abs(dx) > Math.abs(dy)) { if (Math.abs(dx) > 30) dx > 0 ? (targetLane < 2 && targetLane++) : (targetLane > 0 && targetLane--); }
				else { if (Math.abs(dy) > 30) dy < 0 ? (!isJumping && !jetpackActive && (isJumping = true, verticalVelocity = CONFIG.JUMP_FORCE, isSliding = false, player.scale.y = 1)) : (!jetpackActive && (isSliding = true, slideTimer = 0.8, verticalVelocity = -0.5)); }
			});
		}

		function setupUI() {
			document.getElementById('restart-btn').onclick = () => { Leaderboard.save(document.getElementById('name-input').value.trim(), score, survivalTime); startGame(); };
			document.getElementById('lang-btn').onclick = () => { currentLang = currentLang === 'en' ? 'cn' : 'en'; updateLocalization(); };
			updateLocalization();
		}

		init();
	</script>
</body>

</html>